// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: user.proto

#ifndef PROTOBUF_INCLUDED_user_2eproto
#define PROTOBUF_INCLUDED_user_2eproto

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3006001
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
#include "common.pb.h"
// @@protoc_insertion_point(includes)
#define PROTOBUF_INTERNAL_EXPORT_protobuf_user_2eproto 

namespace protobuf_user_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[7];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
}  // namespace protobuf_user_2eproto
namespace im_user {
class forced_offline_ntf;
class forced_offline_ntfDefaultTypeInternal;
extern forced_offline_ntfDefaultTypeInternal _forced_offline_ntf_default_instance_;
class ulogin;
class uloginDefaultTypeInternal;
extern uloginDefaultTypeInternal _ulogin_default_instance_;
class ulogin_ack;
class ulogin_ackDefaultTypeInternal;
extern ulogin_ackDefaultTypeInternal _ulogin_ack_default_instance_;
class ulogin_comfirm;
class ulogin_comfirmDefaultTypeInternal;
extern ulogin_comfirmDefaultTypeInternal _ulogin_comfirm_default_instance_;
class ulogin_comfirm_ack;
class ulogin_comfirm_ackDefaultTypeInternal;
extern ulogin_comfirm_ackDefaultTypeInternal _ulogin_comfirm_ack_default_instance_;
class ulogout;
class ulogoutDefaultTypeInternal;
extern ulogoutDefaultTypeInternal _ulogout_default_instance_;
class ulogout_ack;
class ulogout_ackDefaultTypeInternal;
extern ulogout_ackDefaultTypeInternal _ulogout_ack_default_instance_;
}  // namespace im_user
namespace google {
namespace protobuf {
template<> ::im_user::forced_offline_ntf* Arena::CreateMaybeMessage<::im_user::forced_offline_ntf>(Arena*);
template<> ::im_user::ulogin* Arena::CreateMaybeMessage<::im_user::ulogin>(Arena*);
template<> ::im_user::ulogin_ack* Arena::CreateMaybeMessage<::im_user::ulogin_ack>(Arena*);
template<> ::im_user::ulogin_comfirm* Arena::CreateMaybeMessage<::im_user::ulogin_comfirm>(Arena*);
template<> ::im_user::ulogin_comfirm_ack* Arena::CreateMaybeMessage<::im_user::ulogin_comfirm_ack>(Arena*);
template<> ::im_user::ulogout* Arena::CreateMaybeMessage<::im_user::ulogout>(Arena*);
template<> ::im_user::ulogout_ack* Arena::CreateMaybeMessage<::im_user::ulogout_ack>(Arena*);
}  // namespace protobuf
}  // namespace google
namespace im_user {

// ===================================================================

class ulogin : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:im_user.ulogin) */ {
 public:
  ulogin();
  virtual ~ulogin();

  ulogin(const ulogin& from);

  inline ulogin& operator=(const ulogin& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ulogin(ulogin&& from) noexcept
    : ulogin() {
    *this = ::std::move(from);
  }

  inline ulogin& operator=(ulogin&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ulogin& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ulogin* internal_default_instance() {
    return reinterpret_cast<const ulogin*>(
               &_ulogin_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(ulogin* other);
  friend void swap(ulogin& a, ulogin& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ulogin* New() const final {
    return CreateMaybeMessage<ulogin>(NULL);
  }

  ulogin* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ulogin>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ulogin& from);
  void MergeFrom(const ulogin& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ulogin* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bytes imToken = 2;
  bool has_imtoken() const;
  void clear_imtoken();
  static const int kImTokenFieldNumber = 2;
  const ::std::string& imtoken() const;
  void set_imtoken(const ::std::string& value);
  #if LANG_CXX11
  void set_imtoken(::std::string&& value);
  #endif
  void set_imtoken(const char* value);
  void set_imtoken(const void* value, size_t size);
  ::std::string* mutable_imtoken();
  ::std::string* release_imtoken();
  void set_allocated_imtoken(::std::string* imtoken);

  // optional bytes deviceInfo = 4;
  bool has_deviceinfo() const;
  void clear_deviceinfo();
  static const int kDeviceInfoFieldNumber = 4;
  const ::std::string& deviceinfo() const;
  void set_deviceinfo(const ::std::string& value);
  #if LANG_CXX11
  void set_deviceinfo(::std::string&& value);
  #endif
  void set_deviceinfo(const char* value);
  void set_deviceinfo(const void* value, size_t size);
  ::std::string* mutable_deviceinfo();
  ::std::string* release_deviceinfo();
  void set_allocated_deviceinfo(::std::string* deviceinfo);

  // optional bytes clientip = 6;
  bool has_clientip() const;
  void clear_clientip();
  static const int kClientipFieldNumber = 6;
  const ::std::string& clientip() const;
  void set_clientip(const ::std::string& value);
  #if LANG_CXX11
  void set_clientip(::std::string&& value);
  #endif
  void set_clientip(const char* value);
  void set_clientip(const void* value, size_t size);
  ::std::string* mutable_clientip();
  ::std::string* release_clientip();
  void set_allocated_clientip(::std::string* clientip);

  // optional bytes serv_nodeIdentify = 7;
  bool has_serv_nodeidentify() const;
  void clear_serv_nodeidentify();
  static const int kServNodeIdentifyFieldNumber = 7;
  const ::std::string& serv_nodeidentify() const;
  void set_serv_nodeidentify(const ::std::string& value);
  #if LANG_CXX11
  void set_serv_nodeidentify(::std::string&& value);
  #endif
  void set_serv_nodeidentify(const char* value);
  void set_serv_nodeidentify(const void* value, size_t size);
  ::std::string* mutable_serv_nodeidentify();
  ::std::string* release_serv_nodeidentify();
  void set_allocated_serv_nodeidentify(::std::string* serv_nodeidentify);

  // required uint32 imid = 1;
  bool has_imid() const;
  void clear_imid();
  static const int kImidFieldNumber = 1;
  ::google::protobuf::uint32 imid() const;
  void set_imid(::google::protobuf::uint32 value);

  // optional uint32 clienttype = 3;
  bool has_clienttype() const;
  void clear_clienttype();
  static const int kClienttypeFieldNumber = 3;
  ::google::protobuf::uint32 clienttype() const;
  void set_clienttype(::google::protobuf::uint32 value);

  // optional uint32 app_version = 5;
  bool has_app_version() const;
  void clear_app_version();
  static const int kAppVersionFieldNumber = 5;
  ::google::protobuf::uint32 app_version() const;
  void set_app_version(::google::protobuf::uint32 value);

  // optional uint32 push_chat_msg = 8;
  bool has_push_chat_msg() const;
  void clear_push_chat_msg();
  static const int kPushChatMsgFieldNumber = 8;
  ::google::protobuf::uint32 push_chat_msg() const;
  void set_push_chat_msg(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:im_user.ulogin)
 private:
  void set_has_imid();
  void clear_has_imid();
  void set_has_imtoken();
  void clear_has_imtoken();
  void set_has_clienttype();
  void clear_has_clienttype();
  void set_has_deviceinfo();
  void clear_has_deviceinfo();
  void set_has_app_version();
  void clear_has_app_version();
  void set_has_clientip();
  void clear_has_clientip();
  void set_has_serv_nodeidentify();
  void clear_has_serv_nodeidentify();
  void set_has_push_chat_msg();
  void clear_has_push_chat_msg();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr imtoken_;
  ::google::protobuf::internal::ArenaStringPtr deviceinfo_;
  ::google::protobuf::internal::ArenaStringPtr clientip_;
  ::google::protobuf::internal::ArenaStringPtr serv_nodeidentify_;
  ::google::protobuf::uint32 imid_;
  ::google::protobuf::uint32 clienttype_;
  ::google::protobuf::uint32 app_version_;
  ::google::protobuf::uint32 push_chat_msg_;
  friend struct ::protobuf_user_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ulogin_ack : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:im_user.ulogin_ack) */ {
 public:
  ulogin_ack();
  virtual ~ulogin_ack();

  ulogin_ack(const ulogin_ack& from);

  inline ulogin_ack& operator=(const ulogin_ack& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ulogin_ack(ulogin_ack&& from) noexcept
    : ulogin_ack() {
    *this = ::std::move(from);
  }

  inline ulogin_ack& operator=(ulogin_ack&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ulogin_ack& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ulogin_ack* internal_default_instance() {
    return reinterpret_cast<const ulogin_ack*>(
               &_ulogin_ack_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(ulogin_ack* other);
  friend void swap(ulogin_ack& a, ulogin_ack& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ulogin_ack* New() const final {
    return CreateMaybeMessage<ulogin_ack>(NULL);
  }

  ulogin_ack* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ulogin_ack>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ulogin_ack& from);
  void MergeFrom(const ulogin_ack& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ulogin_ack* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .common.errorinfo error = 1;
  bool has_error() const;
  void clear_error();
  static const int kErrorFieldNumber = 1;
  private:
  const ::common::errorinfo& _internal_error() const;
  public:
  const ::common::errorinfo& error() const;
  ::common::errorinfo* release_error();
  ::common::errorinfo* mutable_error();
  void set_allocated_error(::common::errorinfo* error);

  // optional uint32 beat_time = 2;
  bool has_beat_time() const;
  void clear_beat_time();
  static const int kBeatTimeFieldNumber = 2;
  ::google::protobuf::uint32 beat_time() const;
  void set_beat_time(::google::protobuf::uint32 value);

  // optional uint32 login_prompt = 3;
  bool has_login_prompt() const;
  void clear_login_prompt();
  static const int kLoginPromptFieldNumber = 3;
  ::google::protobuf::uint32 login_prompt() const;
  void set_login_prompt(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:im_user.ulogin_ack)
 private:
  void set_has_error();
  void clear_has_error();
  void set_has_beat_time();
  void clear_has_beat_time();
  void set_has_login_prompt();
  void clear_has_login_prompt();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::common::errorinfo* error_;
  ::google::protobuf::uint32 beat_time_;
  ::google::protobuf::uint32 login_prompt_;
  friend struct ::protobuf_user_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ulogin_comfirm : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:im_user.ulogin_comfirm) */ {
 public:
  ulogin_comfirm();
  virtual ~ulogin_comfirm();

  ulogin_comfirm(const ulogin_comfirm& from);

  inline ulogin_comfirm& operator=(const ulogin_comfirm& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ulogin_comfirm(ulogin_comfirm&& from) noexcept
    : ulogin_comfirm() {
    *this = ::std::move(from);
  }

  inline ulogin_comfirm& operator=(ulogin_comfirm&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ulogin_comfirm& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ulogin_comfirm* internal_default_instance() {
    return reinterpret_cast<const ulogin_comfirm*>(
               &_ulogin_comfirm_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void Swap(ulogin_comfirm* other);
  friend void swap(ulogin_comfirm& a, ulogin_comfirm& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ulogin_comfirm* New() const final {
    return CreateMaybeMessage<ulogin_comfirm>(NULL);
  }

  ulogin_comfirm* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ulogin_comfirm>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ulogin_comfirm& from);
  void MergeFrom(const ulogin_comfirm& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ulogin_comfirm* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes deviceInfo = 1;
  bool has_deviceinfo() const;
  void clear_deviceinfo();
  static const int kDeviceInfoFieldNumber = 1;
  const ::std::string& deviceinfo() const;
  void set_deviceinfo(const ::std::string& value);
  #if LANG_CXX11
  void set_deviceinfo(::std::string&& value);
  #endif
  void set_deviceinfo(const char* value);
  void set_deviceinfo(const void* value, size_t size);
  ::std::string* mutable_deviceinfo();
  ::std::string* release_deviceinfo();
  void set_allocated_deviceinfo(::std::string* deviceinfo);

  // @@protoc_insertion_point(class_scope:im_user.ulogin_comfirm)
 private:
  void set_has_deviceinfo();
  void clear_has_deviceinfo();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr deviceinfo_;
  friend struct ::protobuf_user_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ulogin_comfirm_ack : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:im_user.ulogin_comfirm_ack) */ {
 public:
  ulogin_comfirm_ack();
  virtual ~ulogin_comfirm_ack();

  ulogin_comfirm_ack(const ulogin_comfirm_ack& from);

  inline ulogin_comfirm_ack& operator=(const ulogin_comfirm_ack& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ulogin_comfirm_ack(ulogin_comfirm_ack&& from) noexcept
    : ulogin_comfirm_ack() {
    *this = ::std::move(from);
  }

  inline ulogin_comfirm_ack& operator=(ulogin_comfirm_ack&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ulogin_comfirm_ack& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ulogin_comfirm_ack* internal_default_instance() {
    return reinterpret_cast<const ulogin_comfirm_ack*>(
               &_ulogin_comfirm_ack_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void Swap(ulogin_comfirm_ack* other);
  friend void swap(ulogin_comfirm_ack& a, ulogin_comfirm_ack& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ulogin_comfirm_ack* New() const final {
    return CreateMaybeMessage<ulogin_comfirm_ack>(NULL);
  }

  ulogin_comfirm_ack* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ulogin_comfirm_ack>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ulogin_comfirm_ack& from);
  void MergeFrom(const ulogin_comfirm_ack& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ulogin_comfirm_ack* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .common.errorinfo error = 1;
  bool has_error() const;
  void clear_error();
  static const int kErrorFieldNumber = 1;
  private:
  const ::common::errorinfo& _internal_error() const;
  public:
  const ::common::errorinfo& error() const;
  ::common::errorinfo* release_error();
  ::common::errorinfo* mutable_error();
  void set_allocated_error(::common::errorinfo* error);

  // @@protoc_insertion_point(class_scope:im_user.ulogin_comfirm_ack)
 private:
  void set_has_error();
  void clear_has_error();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::common::errorinfo* error_;
  friend struct ::protobuf_user_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ulogout : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:im_user.ulogout) */ {
 public:
  ulogout();
  virtual ~ulogout();

  ulogout(const ulogout& from);

  inline ulogout& operator=(const ulogout& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ulogout(ulogout&& from) noexcept
    : ulogout() {
    *this = ::std::move(from);
  }

  inline ulogout& operator=(ulogout&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ulogout& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ulogout* internal_default_instance() {
    return reinterpret_cast<const ulogout*>(
               &_ulogout_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  void Swap(ulogout* other);
  friend void swap(ulogout& a, ulogout& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ulogout* New() const final {
    return CreateMaybeMessage<ulogout>(NULL);
  }

  ulogout* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ulogout>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ulogout& from);
  void MergeFrom(const ulogout& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ulogout* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 imid = 1;
  bool has_imid() const;
  void clear_imid();
  static const int kImidFieldNumber = 1;
  ::google::protobuf::uint32 imid() const;
  void set_imid(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:im_user.ulogout)
 private:
  void set_has_imid();
  void clear_has_imid();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 imid_;
  friend struct ::protobuf_user_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ulogout_ack : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:im_user.ulogout_ack) */ {
 public:
  ulogout_ack();
  virtual ~ulogout_ack();

  ulogout_ack(const ulogout_ack& from);

  inline ulogout_ack& operator=(const ulogout_ack& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ulogout_ack(ulogout_ack&& from) noexcept
    : ulogout_ack() {
    *this = ::std::move(from);
  }

  inline ulogout_ack& operator=(ulogout_ack&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ulogout_ack& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ulogout_ack* internal_default_instance() {
    return reinterpret_cast<const ulogout_ack*>(
               &_ulogout_ack_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  void Swap(ulogout_ack* other);
  friend void swap(ulogout_ack& a, ulogout_ack& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ulogout_ack* New() const final {
    return CreateMaybeMessage<ulogout_ack>(NULL);
  }

  ulogout_ack* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ulogout_ack>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ulogout_ack& from);
  void MergeFrom(const ulogout_ack& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ulogout_ack* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .common.errorinfo error = 1;
  bool has_error() const;
  void clear_error();
  static const int kErrorFieldNumber = 1;
  private:
  const ::common::errorinfo& _internal_error() const;
  public:
  const ::common::errorinfo& error() const;
  ::common::errorinfo* release_error();
  ::common::errorinfo* mutable_error();
  void set_allocated_error(::common::errorinfo* error);

  // @@protoc_insertion_point(class_scope:im_user.ulogout_ack)
 private:
  void set_has_error();
  void clear_has_error();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::common::errorinfo* error_;
  friend struct ::protobuf_user_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class forced_offline_ntf : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:im_user.forced_offline_ntf) */ {
 public:
  forced_offline_ntf();
  virtual ~forced_offline_ntf();

  forced_offline_ntf(const forced_offline_ntf& from);

  inline forced_offline_ntf& operator=(const forced_offline_ntf& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  forced_offline_ntf(forced_offline_ntf&& from) noexcept
    : forced_offline_ntf() {
    *this = ::std::move(from);
  }

  inline forced_offline_ntf& operator=(forced_offline_ntf&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const forced_offline_ntf& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const forced_offline_ntf* internal_default_instance() {
    return reinterpret_cast<const forced_offline_ntf*>(
               &_forced_offline_ntf_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  void Swap(forced_offline_ntf* other);
  friend void swap(forced_offline_ntf& a, forced_offline_ntf& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline forced_offline_ntf* New() const final {
    return CreateMaybeMessage<forced_offline_ntf>(NULL);
  }

  forced_offline_ntf* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<forced_offline_ntf>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const forced_offline_ntf& from);
  void MergeFrom(const forced_offline_ntf& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(forced_offline_ntf* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .common.errorinfo error = 1;
  bool has_error() const;
  void clear_error();
  static const int kErrorFieldNumber = 1;
  private:
  const ::common::errorinfo& _internal_error() const;
  public:
  const ::common::errorinfo& error() const;
  ::common::errorinfo* release_error();
  ::common::errorinfo* mutable_error();
  void set_allocated_error(::common::errorinfo* error);

  // @@protoc_insertion_point(class_scope:im_user.forced_offline_ntf)
 private:
  void set_has_error();
  void clear_has_error();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::common::errorinfo* error_;
  friend struct ::protobuf_user_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// ulogin

// required uint32 imid = 1;
inline bool ulogin::has_imid() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ulogin::set_has_imid() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ulogin::clear_has_imid() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ulogin::clear_imid() {
  imid_ = 0u;
  clear_has_imid();
}
inline ::google::protobuf::uint32 ulogin::imid() const {
  // @@protoc_insertion_point(field_get:im_user.ulogin.imid)
  return imid_;
}
inline void ulogin::set_imid(::google::protobuf::uint32 value) {
  set_has_imid();
  imid_ = value;
  // @@protoc_insertion_point(field_set:im_user.ulogin.imid)
}

// required bytes imToken = 2;
inline bool ulogin::has_imtoken() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ulogin::set_has_imtoken() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ulogin::clear_has_imtoken() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ulogin::clear_imtoken() {
  imtoken_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_imtoken();
}
inline const ::std::string& ulogin::imtoken() const {
  // @@protoc_insertion_point(field_get:im_user.ulogin.imToken)
  return imtoken_.GetNoArena();
}
inline void ulogin::set_imtoken(const ::std::string& value) {
  set_has_imtoken();
  imtoken_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:im_user.ulogin.imToken)
}
#if LANG_CXX11
inline void ulogin::set_imtoken(::std::string&& value) {
  set_has_imtoken();
  imtoken_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:im_user.ulogin.imToken)
}
#endif
inline void ulogin::set_imtoken(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_imtoken();
  imtoken_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:im_user.ulogin.imToken)
}
inline void ulogin::set_imtoken(const void* value, size_t size) {
  set_has_imtoken();
  imtoken_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:im_user.ulogin.imToken)
}
inline ::std::string* ulogin::mutable_imtoken() {
  set_has_imtoken();
  // @@protoc_insertion_point(field_mutable:im_user.ulogin.imToken)
  return imtoken_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ulogin::release_imtoken() {
  // @@protoc_insertion_point(field_release:im_user.ulogin.imToken)
  if (!has_imtoken()) {
    return NULL;
  }
  clear_has_imtoken();
  return imtoken_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ulogin::set_allocated_imtoken(::std::string* imtoken) {
  if (imtoken != NULL) {
    set_has_imtoken();
  } else {
    clear_has_imtoken();
  }
  imtoken_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), imtoken);
  // @@protoc_insertion_point(field_set_allocated:im_user.ulogin.imToken)
}

// optional uint32 clienttype = 3;
inline bool ulogin::has_clienttype() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ulogin::set_has_clienttype() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ulogin::clear_has_clienttype() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ulogin::clear_clienttype() {
  clienttype_ = 0u;
  clear_has_clienttype();
}
inline ::google::protobuf::uint32 ulogin::clienttype() const {
  // @@protoc_insertion_point(field_get:im_user.ulogin.clienttype)
  return clienttype_;
}
inline void ulogin::set_clienttype(::google::protobuf::uint32 value) {
  set_has_clienttype();
  clienttype_ = value;
  // @@protoc_insertion_point(field_set:im_user.ulogin.clienttype)
}

// optional bytes deviceInfo = 4;
inline bool ulogin::has_deviceinfo() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ulogin::set_has_deviceinfo() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ulogin::clear_has_deviceinfo() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ulogin::clear_deviceinfo() {
  deviceinfo_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_deviceinfo();
}
inline const ::std::string& ulogin::deviceinfo() const {
  // @@protoc_insertion_point(field_get:im_user.ulogin.deviceInfo)
  return deviceinfo_.GetNoArena();
}
inline void ulogin::set_deviceinfo(const ::std::string& value) {
  set_has_deviceinfo();
  deviceinfo_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:im_user.ulogin.deviceInfo)
}
#if LANG_CXX11
inline void ulogin::set_deviceinfo(::std::string&& value) {
  set_has_deviceinfo();
  deviceinfo_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:im_user.ulogin.deviceInfo)
}
#endif
inline void ulogin::set_deviceinfo(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_deviceinfo();
  deviceinfo_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:im_user.ulogin.deviceInfo)
}
inline void ulogin::set_deviceinfo(const void* value, size_t size) {
  set_has_deviceinfo();
  deviceinfo_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:im_user.ulogin.deviceInfo)
}
inline ::std::string* ulogin::mutable_deviceinfo() {
  set_has_deviceinfo();
  // @@protoc_insertion_point(field_mutable:im_user.ulogin.deviceInfo)
  return deviceinfo_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ulogin::release_deviceinfo() {
  // @@protoc_insertion_point(field_release:im_user.ulogin.deviceInfo)
  if (!has_deviceinfo()) {
    return NULL;
  }
  clear_has_deviceinfo();
  return deviceinfo_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ulogin::set_allocated_deviceinfo(::std::string* deviceinfo) {
  if (deviceinfo != NULL) {
    set_has_deviceinfo();
  } else {
    clear_has_deviceinfo();
  }
  deviceinfo_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), deviceinfo);
  // @@protoc_insertion_point(field_set_allocated:im_user.ulogin.deviceInfo)
}

// optional uint32 app_version = 5;
inline bool ulogin::has_app_version() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void ulogin::set_has_app_version() {
  _has_bits_[0] |= 0x00000040u;
}
inline void ulogin::clear_has_app_version() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void ulogin::clear_app_version() {
  app_version_ = 0u;
  clear_has_app_version();
}
inline ::google::protobuf::uint32 ulogin::app_version() const {
  // @@protoc_insertion_point(field_get:im_user.ulogin.app_version)
  return app_version_;
}
inline void ulogin::set_app_version(::google::protobuf::uint32 value) {
  set_has_app_version();
  app_version_ = value;
  // @@protoc_insertion_point(field_set:im_user.ulogin.app_version)
}

// optional bytes clientip = 6;
inline bool ulogin::has_clientip() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ulogin::set_has_clientip() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ulogin::clear_has_clientip() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ulogin::clear_clientip() {
  clientip_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_clientip();
}
inline const ::std::string& ulogin::clientip() const {
  // @@protoc_insertion_point(field_get:im_user.ulogin.clientip)
  return clientip_.GetNoArena();
}
inline void ulogin::set_clientip(const ::std::string& value) {
  set_has_clientip();
  clientip_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:im_user.ulogin.clientip)
}
#if LANG_CXX11
inline void ulogin::set_clientip(::std::string&& value) {
  set_has_clientip();
  clientip_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:im_user.ulogin.clientip)
}
#endif
inline void ulogin::set_clientip(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_clientip();
  clientip_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:im_user.ulogin.clientip)
}
inline void ulogin::set_clientip(const void* value, size_t size) {
  set_has_clientip();
  clientip_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:im_user.ulogin.clientip)
}
inline ::std::string* ulogin::mutable_clientip() {
  set_has_clientip();
  // @@protoc_insertion_point(field_mutable:im_user.ulogin.clientip)
  return clientip_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ulogin::release_clientip() {
  // @@protoc_insertion_point(field_release:im_user.ulogin.clientip)
  if (!has_clientip()) {
    return NULL;
  }
  clear_has_clientip();
  return clientip_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ulogin::set_allocated_clientip(::std::string* clientip) {
  if (clientip != NULL) {
    set_has_clientip();
  } else {
    clear_has_clientip();
  }
  clientip_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), clientip);
  // @@protoc_insertion_point(field_set_allocated:im_user.ulogin.clientip)
}

// optional bytes serv_nodeIdentify = 7;
inline bool ulogin::has_serv_nodeidentify() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ulogin::set_has_serv_nodeidentify() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ulogin::clear_has_serv_nodeidentify() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ulogin::clear_serv_nodeidentify() {
  serv_nodeidentify_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_serv_nodeidentify();
}
inline const ::std::string& ulogin::serv_nodeidentify() const {
  // @@protoc_insertion_point(field_get:im_user.ulogin.serv_nodeIdentify)
  return serv_nodeidentify_.GetNoArena();
}
inline void ulogin::set_serv_nodeidentify(const ::std::string& value) {
  set_has_serv_nodeidentify();
  serv_nodeidentify_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:im_user.ulogin.serv_nodeIdentify)
}
#if LANG_CXX11
inline void ulogin::set_serv_nodeidentify(::std::string&& value) {
  set_has_serv_nodeidentify();
  serv_nodeidentify_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:im_user.ulogin.serv_nodeIdentify)
}
#endif
inline void ulogin::set_serv_nodeidentify(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_serv_nodeidentify();
  serv_nodeidentify_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:im_user.ulogin.serv_nodeIdentify)
}
inline void ulogin::set_serv_nodeidentify(const void* value, size_t size) {
  set_has_serv_nodeidentify();
  serv_nodeidentify_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:im_user.ulogin.serv_nodeIdentify)
}
inline ::std::string* ulogin::mutable_serv_nodeidentify() {
  set_has_serv_nodeidentify();
  // @@protoc_insertion_point(field_mutable:im_user.ulogin.serv_nodeIdentify)
  return serv_nodeidentify_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ulogin::release_serv_nodeidentify() {
  // @@protoc_insertion_point(field_release:im_user.ulogin.serv_nodeIdentify)
  if (!has_serv_nodeidentify()) {
    return NULL;
  }
  clear_has_serv_nodeidentify();
  return serv_nodeidentify_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ulogin::set_allocated_serv_nodeidentify(::std::string* serv_nodeidentify) {
  if (serv_nodeidentify != NULL) {
    set_has_serv_nodeidentify();
  } else {
    clear_has_serv_nodeidentify();
  }
  serv_nodeidentify_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), serv_nodeidentify);
  // @@protoc_insertion_point(field_set_allocated:im_user.ulogin.serv_nodeIdentify)
}

// optional uint32 push_chat_msg = 8;
inline bool ulogin::has_push_chat_msg() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void ulogin::set_has_push_chat_msg() {
  _has_bits_[0] |= 0x00000080u;
}
inline void ulogin::clear_has_push_chat_msg() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void ulogin::clear_push_chat_msg() {
  push_chat_msg_ = 0u;
  clear_has_push_chat_msg();
}
inline ::google::protobuf::uint32 ulogin::push_chat_msg() const {
  // @@protoc_insertion_point(field_get:im_user.ulogin.push_chat_msg)
  return push_chat_msg_;
}
inline void ulogin::set_push_chat_msg(::google::protobuf::uint32 value) {
  set_has_push_chat_msg();
  push_chat_msg_ = value;
  // @@protoc_insertion_point(field_set:im_user.ulogin.push_chat_msg)
}

// -------------------------------------------------------------------

// ulogin_ack

// optional .common.errorinfo error = 1;
inline bool ulogin_ack::has_error() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ulogin_ack::set_has_error() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ulogin_ack::clear_has_error() {
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::common::errorinfo& ulogin_ack::_internal_error() const {
  return *error_;
}
inline const ::common::errorinfo& ulogin_ack::error() const {
  const ::common::errorinfo* p = error_;
  // @@protoc_insertion_point(field_get:im_user.ulogin_ack.error)
  return p != NULL ? *p : *reinterpret_cast<const ::common::errorinfo*>(
      &::common::_errorinfo_default_instance_);
}
inline ::common::errorinfo* ulogin_ack::release_error() {
  // @@protoc_insertion_point(field_release:im_user.ulogin_ack.error)
  clear_has_error();
  ::common::errorinfo* temp = error_;
  error_ = NULL;
  return temp;
}
inline ::common::errorinfo* ulogin_ack::mutable_error() {
  set_has_error();
  if (error_ == NULL) {
    auto* p = CreateMaybeMessage<::common::errorinfo>(GetArenaNoVirtual());
    error_ = p;
  }
  // @@protoc_insertion_point(field_mutable:im_user.ulogin_ack.error)
  return error_;
}
inline void ulogin_ack::set_allocated_error(::common::errorinfo* error) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(error_);
  }
  if (error) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      error = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, error, submessage_arena);
    }
    set_has_error();
  } else {
    clear_has_error();
  }
  error_ = error;
  // @@protoc_insertion_point(field_set_allocated:im_user.ulogin_ack.error)
}

// optional uint32 beat_time = 2;
inline bool ulogin_ack::has_beat_time() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ulogin_ack::set_has_beat_time() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ulogin_ack::clear_has_beat_time() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ulogin_ack::clear_beat_time() {
  beat_time_ = 0u;
  clear_has_beat_time();
}
inline ::google::protobuf::uint32 ulogin_ack::beat_time() const {
  // @@protoc_insertion_point(field_get:im_user.ulogin_ack.beat_time)
  return beat_time_;
}
inline void ulogin_ack::set_beat_time(::google::protobuf::uint32 value) {
  set_has_beat_time();
  beat_time_ = value;
  // @@protoc_insertion_point(field_set:im_user.ulogin_ack.beat_time)
}

// optional uint32 login_prompt = 3;
inline bool ulogin_ack::has_login_prompt() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ulogin_ack::set_has_login_prompt() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ulogin_ack::clear_has_login_prompt() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ulogin_ack::clear_login_prompt() {
  login_prompt_ = 0u;
  clear_has_login_prompt();
}
inline ::google::protobuf::uint32 ulogin_ack::login_prompt() const {
  // @@protoc_insertion_point(field_get:im_user.ulogin_ack.login_prompt)
  return login_prompt_;
}
inline void ulogin_ack::set_login_prompt(::google::protobuf::uint32 value) {
  set_has_login_prompt();
  login_prompt_ = value;
  // @@protoc_insertion_point(field_set:im_user.ulogin_ack.login_prompt)
}

// -------------------------------------------------------------------

// ulogin_comfirm

// optional bytes deviceInfo = 1;
inline bool ulogin_comfirm::has_deviceinfo() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ulogin_comfirm::set_has_deviceinfo() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ulogin_comfirm::clear_has_deviceinfo() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ulogin_comfirm::clear_deviceinfo() {
  deviceinfo_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_deviceinfo();
}
inline const ::std::string& ulogin_comfirm::deviceinfo() const {
  // @@protoc_insertion_point(field_get:im_user.ulogin_comfirm.deviceInfo)
  return deviceinfo_.GetNoArena();
}
inline void ulogin_comfirm::set_deviceinfo(const ::std::string& value) {
  set_has_deviceinfo();
  deviceinfo_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:im_user.ulogin_comfirm.deviceInfo)
}
#if LANG_CXX11
inline void ulogin_comfirm::set_deviceinfo(::std::string&& value) {
  set_has_deviceinfo();
  deviceinfo_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:im_user.ulogin_comfirm.deviceInfo)
}
#endif
inline void ulogin_comfirm::set_deviceinfo(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_deviceinfo();
  deviceinfo_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:im_user.ulogin_comfirm.deviceInfo)
}
inline void ulogin_comfirm::set_deviceinfo(const void* value, size_t size) {
  set_has_deviceinfo();
  deviceinfo_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:im_user.ulogin_comfirm.deviceInfo)
}
inline ::std::string* ulogin_comfirm::mutable_deviceinfo() {
  set_has_deviceinfo();
  // @@protoc_insertion_point(field_mutable:im_user.ulogin_comfirm.deviceInfo)
  return deviceinfo_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ulogin_comfirm::release_deviceinfo() {
  // @@protoc_insertion_point(field_release:im_user.ulogin_comfirm.deviceInfo)
  if (!has_deviceinfo()) {
    return NULL;
  }
  clear_has_deviceinfo();
  return deviceinfo_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ulogin_comfirm::set_allocated_deviceinfo(::std::string* deviceinfo) {
  if (deviceinfo != NULL) {
    set_has_deviceinfo();
  } else {
    clear_has_deviceinfo();
  }
  deviceinfo_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), deviceinfo);
  // @@protoc_insertion_point(field_set_allocated:im_user.ulogin_comfirm.deviceInfo)
}

// -------------------------------------------------------------------

// ulogin_comfirm_ack

// optional .common.errorinfo error = 1;
inline bool ulogin_comfirm_ack::has_error() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ulogin_comfirm_ack::set_has_error() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ulogin_comfirm_ack::clear_has_error() {
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::common::errorinfo& ulogin_comfirm_ack::_internal_error() const {
  return *error_;
}
inline const ::common::errorinfo& ulogin_comfirm_ack::error() const {
  const ::common::errorinfo* p = error_;
  // @@protoc_insertion_point(field_get:im_user.ulogin_comfirm_ack.error)
  return p != NULL ? *p : *reinterpret_cast<const ::common::errorinfo*>(
      &::common::_errorinfo_default_instance_);
}
inline ::common::errorinfo* ulogin_comfirm_ack::release_error() {
  // @@protoc_insertion_point(field_release:im_user.ulogin_comfirm_ack.error)
  clear_has_error();
  ::common::errorinfo* temp = error_;
  error_ = NULL;
  return temp;
}
inline ::common::errorinfo* ulogin_comfirm_ack::mutable_error() {
  set_has_error();
  if (error_ == NULL) {
    auto* p = CreateMaybeMessage<::common::errorinfo>(GetArenaNoVirtual());
    error_ = p;
  }
  // @@protoc_insertion_point(field_mutable:im_user.ulogin_comfirm_ack.error)
  return error_;
}
inline void ulogin_comfirm_ack::set_allocated_error(::common::errorinfo* error) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(error_);
  }
  if (error) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      error = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, error, submessage_arena);
    }
    set_has_error();
  } else {
    clear_has_error();
  }
  error_ = error;
  // @@protoc_insertion_point(field_set_allocated:im_user.ulogin_comfirm_ack.error)
}

// -------------------------------------------------------------------

// ulogout

// required uint32 imid = 1;
inline bool ulogout::has_imid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ulogout::set_has_imid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ulogout::clear_has_imid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ulogout::clear_imid() {
  imid_ = 0u;
  clear_has_imid();
}
inline ::google::protobuf::uint32 ulogout::imid() const {
  // @@protoc_insertion_point(field_get:im_user.ulogout.imid)
  return imid_;
}
inline void ulogout::set_imid(::google::protobuf::uint32 value) {
  set_has_imid();
  imid_ = value;
  // @@protoc_insertion_point(field_set:im_user.ulogout.imid)
}

// -------------------------------------------------------------------

// ulogout_ack

// optional .common.errorinfo error = 1;
inline bool ulogout_ack::has_error() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ulogout_ack::set_has_error() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ulogout_ack::clear_has_error() {
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::common::errorinfo& ulogout_ack::_internal_error() const {
  return *error_;
}
inline const ::common::errorinfo& ulogout_ack::error() const {
  const ::common::errorinfo* p = error_;
  // @@protoc_insertion_point(field_get:im_user.ulogout_ack.error)
  return p != NULL ? *p : *reinterpret_cast<const ::common::errorinfo*>(
      &::common::_errorinfo_default_instance_);
}
inline ::common::errorinfo* ulogout_ack::release_error() {
  // @@protoc_insertion_point(field_release:im_user.ulogout_ack.error)
  clear_has_error();
  ::common::errorinfo* temp = error_;
  error_ = NULL;
  return temp;
}
inline ::common::errorinfo* ulogout_ack::mutable_error() {
  set_has_error();
  if (error_ == NULL) {
    auto* p = CreateMaybeMessage<::common::errorinfo>(GetArenaNoVirtual());
    error_ = p;
  }
  // @@protoc_insertion_point(field_mutable:im_user.ulogout_ack.error)
  return error_;
}
inline void ulogout_ack::set_allocated_error(::common::errorinfo* error) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(error_);
  }
  if (error) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      error = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, error, submessage_arena);
    }
    set_has_error();
  } else {
    clear_has_error();
  }
  error_ = error;
  // @@protoc_insertion_point(field_set_allocated:im_user.ulogout_ack.error)
}

// -------------------------------------------------------------------

// forced_offline_ntf

// optional .common.errorinfo error = 1;
inline bool forced_offline_ntf::has_error() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void forced_offline_ntf::set_has_error() {
  _has_bits_[0] |= 0x00000001u;
}
inline void forced_offline_ntf::clear_has_error() {
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::common::errorinfo& forced_offline_ntf::_internal_error() const {
  return *error_;
}
inline const ::common::errorinfo& forced_offline_ntf::error() const {
  const ::common::errorinfo* p = error_;
  // @@protoc_insertion_point(field_get:im_user.forced_offline_ntf.error)
  return p != NULL ? *p : *reinterpret_cast<const ::common::errorinfo*>(
      &::common::_errorinfo_default_instance_);
}
inline ::common::errorinfo* forced_offline_ntf::release_error() {
  // @@protoc_insertion_point(field_release:im_user.forced_offline_ntf.error)
  clear_has_error();
  ::common::errorinfo* temp = error_;
  error_ = NULL;
  return temp;
}
inline ::common::errorinfo* forced_offline_ntf::mutable_error() {
  set_has_error();
  if (error_ == NULL) {
    auto* p = CreateMaybeMessage<::common::errorinfo>(GetArenaNoVirtual());
    error_ = p;
  }
  // @@protoc_insertion_point(field_mutable:im_user.forced_offline_ntf.error)
  return error_;
}
inline void forced_offline_ntf::set_allocated_error(::common::errorinfo* error) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(error_);
  }
  if (error) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      error = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, error, submessage_arena);
    }
    set_has_error();
  } else {
    clear_has_error();
  }
  error_ = error;
  // @@protoc_insertion_point(field_set_allocated:im_user.forced_offline_ntf.error)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace im_user

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_INCLUDED_user_2eproto
