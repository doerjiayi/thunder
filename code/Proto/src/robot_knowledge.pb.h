// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: robot_knowledge.proto

#ifndef PROTOBUF_INCLUDED_robot_5fknowledge_2eproto
#define PROTOBUF_INCLUDED_robot_5fknowledge_2eproto

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3006001
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
#include "common.pb.h"
// @@protoc_insertion_point(includes)
#define PROTOBUF_INTERNAL_EXPORT_protobuf_robot_5fknowledge_2eproto 

namespace protobuf_robot_5fknowledge_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[8];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
}  // namespace protobuf_robot_5fknowledge_2eproto
namespace robot_knowledge {
class ai_question;
class ai_questionDefaultTypeInternal;
extern ai_questionDefaultTypeInternal _ai_question_default_instance_;
class edit_ai_question_ack;
class edit_ai_question_ackDefaultTypeInternal;
extern edit_ai_question_ackDefaultTypeInternal _edit_ai_question_ack_default_instance_;
class edit_ai_question_req;
class edit_ai_question_reqDefaultTypeInternal;
extern edit_ai_question_reqDefaultTypeInternal _edit_ai_question_req_default_instance_;
class get_ai_question_list_ack;
class get_ai_question_list_ackDefaultTypeInternal;
extern get_ai_question_list_ackDefaultTypeInternal _get_ai_question_list_ack_default_instance_;
class get_ai_question_list_req;
class get_ai_question_list_reqDefaultTypeInternal;
extern get_ai_question_list_reqDefaultTypeInternal _get_ai_question_list_req_default_instance_;
class inquery_ai_question_content_ack;
class inquery_ai_question_content_ackDefaultTypeInternal;
extern inquery_ai_question_content_ackDefaultTypeInternal _inquery_ai_question_content_ack_default_instance_;
class inquery_ai_question_content_req;
class inquery_ai_question_content_reqDefaultTypeInternal;
extern inquery_ai_question_content_reqDefaultTypeInternal _inquery_ai_question_content_req_default_instance_;
class similar_question;
class similar_questionDefaultTypeInternal;
extern similar_questionDefaultTypeInternal _similar_question_default_instance_;
}  // namespace robot_knowledge
namespace google {
namespace protobuf {
template<> ::robot_knowledge::ai_question* Arena::CreateMaybeMessage<::robot_knowledge::ai_question>(Arena*);
template<> ::robot_knowledge::edit_ai_question_ack* Arena::CreateMaybeMessage<::robot_knowledge::edit_ai_question_ack>(Arena*);
template<> ::robot_knowledge::edit_ai_question_req* Arena::CreateMaybeMessage<::robot_knowledge::edit_ai_question_req>(Arena*);
template<> ::robot_knowledge::get_ai_question_list_ack* Arena::CreateMaybeMessage<::robot_knowledge::get_ai_question_list_ack>(Arena*);
template<> ::robot_knowledge::get_ai_question_list_req* Arena::CreateMaybeMessage<::robot_knowledge::get_ai_question_list_req>(Arena*);
template<> ::robot_knowledge::inquery_ai_question_content_ack* Arena::CreateMaybeMessage<::robot_knowledge::inquery_ai_question_content_ack>(Arena*);
template<> ::robot_knowledge::inquery_ai_question_content_req* Arena::CreateMaybeMessage<::robot_knowledge::inquery_ai_question_content_req>(Arena*);
template<> ::robot_knowledge::similar_question* Arena::CreateMaybeMessage<::robot_knowledge::similar_question>(Arena*);
}  // namespace protobuf
}  // namespace google
namespace robot_knowledge {

// ===================================================================

class similar_question : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:robot_knowledge.similar_question) */ {
 public:
  similar_question();
  virtual ~similar_question();

  similar_question(const similar_question& from);

  inline similar_question& operator=(const similar_question& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  similar_question(similar_question&& from) noexcept
    : similar_question() {
    *this = ::std::move(from);
  }

  inline similar_question& operator=(similar_question&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const similar_question& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const similar_question* internal_default_instance() {
    return reinterpret_cast<const similar_question*>(
               &_similar_question_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(similar_question* other);
  friend void swap(similar_question& a, similar_question& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline similar_question* New() const final {
    return CreateMaybeMessage<similar_question>(NULL);
  }

  similar_question* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<similar_question>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const similar_question& from);
  void MergeFrom(const similar_question& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(similar_question* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bytes question = 2;
  void clear_question();
  static const int kQuestionFieldNumber = 2;
  const ::std::string& question() const;
  void set_question(const ::std::string& value);
  #if LANG_CXX11
  void set_question(::std::string&& value);
  #endif
  void set_question(const char* value);
  void set_question(const void* value, size_t size);
  ::std::string* mutable_question();
  ::std::string* release_question();
  void set_allocated_question(::std::string* question);

  // uint64 index_id = 1;
  void clear_index_id();
  static const int kIndexIdFieldNumber = 1;
  ::google::protobuf::uint64 index_id() const;
  void set_index_id(::google::protobuf::uint64 value);

  // uint32 create_date = 3;
  void clear_create_date();
  static const int kCreateDateFieldNumber = 3;
  ::google::protobuf::uint32 create_date() const;
  void set_create_date(::google::protobuf::uint32 value);

  // uint32 update_date = 4;
  void clear_update_date();
  static const int kUpdateDateFieldNumber = 4;
  ::google::protobuf::uint32 update_date() const;
  void set_update_date(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:robot_knowledge.similar_question)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr question_;
  ::google::protobuf::uint64 index_id_;
  ::google::protobuf::uint32 create_date_;
  ::google::protobuf::uint32 update_date_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_robot_5fknowledge_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ai_question : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:robot_knowledge.ai_question) */ {
 public:
  ai_question();
  virtual ~ai_question();

  ai_question(const ai_question& from);

  inline ai_question& operator=(const ai_question& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ai_question(ai_question&& from) noexcept
    : ai_question() {
    *this = ::std::move(from);
  }

  inline ai_question& operator=(ai_question&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ai_question& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ai_question* internal_default_instance() {
    return reinterpret_cast<const ai_question*>(
               &_ai_question_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(ai_question* other);
  friend void swap(ai_question& a, ai_question& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ai_question* New() const final {
    return CreateMaybeMessage<ai_question>(NULL);
  }

  ai_question* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ai_question>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ai_question& from);
  void MergeFrom(const ai_question& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ai_question* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .robot_knowledge.similar_question similar_questions_list = 8;
  int similar_questions_list_size() const;
  void clear_similar_questions_list();
  static const int kSimilarQuestionsListFieldNumber = 8;
  ::robot_knowledge::similar_question* mutable_similar_questions_list(int index);
  ::google::protobuf::RepeatedPtrField< ::robot_knowledge::similar_question >*
      mutable_similar_questions_list();
  const ::robot_knowledge::similar_question& similar_questions_list(int index) const;
  ::robot_knowledge::similar_question* add_similar_questions_list();
  const ::google::protobuf::RepeatedPtrField< ::robot_knowledge::similar_question >&
      similar_questions_list() const;

  // bytes question = 4;
  void clear_question();
  static const int kQuestionFieldNumber = 4;
  const ::std::string& question() const;
  void set_question(const ::std::string& value);
  #if LANG_CXX11
  void set_question(::std::string&& value);
  #endif
  void set_question(const char* value);
  void set_question(const void* value, size_t size);
  ::std::string* mutable_question();
  ::std::string* release_question();
  void set_allocated_question(::std::string* question);

  // bytes answer = 5;
  void clear_answer();
  static const int kAnswerFieldNumber = 5;
  const ::std::string& answer() const;
  void set_answer(const ::std::string& value);
  #if LANG_CXX11
  void set_answer(::std::string&& value);
  #endif
  void set_answer(const char* value);
  void set_answer(const void* value, size_t size);
  ::std::string* mutable_answer();
  ::std::string* release_answer();
  void set_allocated_answer(::std::string* answer);

  // uint64 index_id = 1;
  void clear_index_id();
  static const int kIndexIdFieldNumber = 1;
  ::google::protobuf::uint64 index_id() const;
  void set_index_id(::google::protobuf::uint64 value);

  // uint64 standard_question_id = 2;
  void clear_standard_question_id();
  static const int kStandardQuestionIdFieldNumber = 2;
  ::google::protobuf::uint64 standard_question_id() const;
  void set_standard_question_id(::google::protobuf::uint64 value);

  // uint32 question_type = 3;
  void clear_question_type();
  static const int kQuestionTypeFieldNumber = 3;
  ::google::protobuf::uint32 question_type() const;
  void set_question_type(::google::protobuf::uint32 value);

  // uint32 create_date = 6;
  void clear_create_date();
  static const int kCreateDateFieldNumber = 6;
  ::google::protobuf::uint32 create_date() const;
  void set_create_date(::google::protobuf::uint32 value);

  // uint32 update_date = 7;
  void clear_update_date();
  static const int kUpdateDateFieldNumber = 7;
  ::google::protobuf::uint32 update_date() const;
  void set_update_date(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:robot_knowledge.ai_question)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::robot_knowledge::similar_question > similar_questions_list_;
  ::google::protobuf::internal::ArenaStringPtr question_;
  ::google::protobuf::internal::ArenaStringPtr answer_;
  ::google::protobuf::uint64 index_id_;
  ::google::protobuf::uint64 standard_question_id_;
  ::google::protobuf::uint32 question_type_;
  ::google::protobuf::uint32 create_date_;
  ::google::protobuf::uint32 update_date_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_robot_5fknowledge_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class get_ai_question_list_req : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:robot_knowledge.get_ai_question_list_req) */ {
 public:
  get_ai_question_list_req();
  virtual ~get_ai_question_list_req();

  get_ai_question_list_req(const get_ai_question_list_req& from);

  inline get_ai_question_list_req& operator=(const get_ai_question_list_req& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  get_ai_question_list_req(get_ai_question_list_req&& from) noexcept
    : get_ai_question_list_req() {
    *this = ::std::move(from);
  }

  inline get_ai_question_list_req& operator=(get_ai_question_list_req&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const get_ai_question_list_req& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const get_ai_question_list_req* internal_default_instance() {
    return reinterpret_cast<const get_ai_question_list_req*>(
               &_get_ai_question_list_req_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void Swap(get_ai_question_list_req* other);
  friend void swap(get_ai_question_list_req& a, get_ai_question_list_req& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline get_ai_question_list_req* New() const final {
    return CreateMaybeMessage<get_ai_question_list_req>(NULL);
  }

  get_ai_question_list_req* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<get_ai_question_list_req>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const get_ai_question_list_req& from);
  void MergeFrom(const get_ai_question_list_req& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(get_ai_question_list_req* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // uint32 question_type = 1;
  void clear_question_type();
  static const int kQuestionTypeFieldNumber = 1;
  ::google::protobuf::uint32 question_type() const;
  void set_question_type(::google::protobuf::uint32 value);

  // uint32 page = 2;
  void clear_page();
  static const int kPageFieldNumber = 2;
  ::google::protobuf::uint32 page() const;
  void set_page(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:robot_knowledge.get_ai_question_list_req)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 question_type_;
  ::google::protobuf::uint32 page_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_robot_5fknowledge_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class get_ai_question_list_ack : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:robot_knowledge.get_ai_question_list_ack) */ {
 public:
  get_ai_question_list_ack();
  virtual ~get_ai_question_list_ack();

  get_ai_question_list_ack(const get_ai_question_list_ack& from);

  inline get_ai_question_list_ack& operator=(const get_ai_question_list_ack& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  get_ai_question_list_ack(get_ai_question_list_ack&& from) noexcept
    : get_ai_question_list_ack() {
    *this = ::std::move(from);
  }

  inline get_ai_question_list_ack& operator=(get_ai_question_list_ack&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const get_ai_question_list_ack& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const get_ai_question_list_ack* internal_default_instance() {
    return reinterpret_cast<const get_ai_question_list_ack*>(
               &_get_ai_question_list_ack_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void Swap(get_ai_question_list_ack* other);
  friend void swap(get_ai_question_list_ack& a, get_ai_question_list_ack& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline get_ai_question_list_ack* New() const final {
    return CreateMaybeMessage<get_ai_question_list_ack>(NULL);
  }

  get_ai_question_list_ack* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<get_ai_question_list_ack>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const get_ai_question_list_ack& from);
  void MergeFrom(const get_ai_question_list_ack& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(get_ai_question_list_ack* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .robot_knowledge.ai_question ai_question_list = 2;
  int ai_question_list_size() const;
  void clear_ai_question_list();
  static const int kAiQuestionListFieldNumber = 2;
  ::robot_knowledge::ai_question* mutable_ai_question_list(int index);
  ::google::protobuf::RepeatedPtrField< ::robot_knowledge::ai_question >*
      mutable_ai_question_list();
  const ::robot_knowledge::ai_question& ai_question_list(int index) const;
  ::robot_knowledge::ai_question* add_ai_question_list();
  const ::google::protobuf::RepeatedPtrField< ::robot_knowledge::ai_question >&
      ai_question_list() const;

  // .common.errorinfo error = 1;
  bool has_error() const;
  void clear_error();
  static const int kErrorFieldNumber = 1;
  private:
  const ::common::errorinfo& _internal_error() const;
  public:
  const ::common::errorinfo& error() const;
  ::common::errorinfo* release_error();
  ::common::errorinfo* mutable_error();
  void set_allocated_error(::common::errorinfo* error);

  // uint32 total_num = 3;
  void clear_total_num();
  static const int kTotalNumFieldNumber = 3;
  ::google::protobuf::uint32 total_num() const;
  void set_total_num(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:robot_knowledge.get_ai_question_list_ack)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::robot_knowledge::ai_question > ai_question_list_;
  ::common::errorinfo* error_;
  ::google::protobuf::uint32 total_num_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_robot_5fknowledge_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class inquery_ai_question_content_req : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:robot_knowledge.inquery_ai_question_content_req) */ {
 public:
  inquery_ai_question_content_req();
  virtual ~inquery_ai_question_content_req();

  inquery_ai_question_content_req(const inquery_ai_question_content_req& from);

  inline inquery_ai_question_content_req& operator=(const inquery_ai_question_content_req& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  inquery_ai_question_content_req(inquery_ai_question_content_req&& from) noexcept
    : inquery_ai_question_content_req() {
    *this = ::std::move(from);
  }

  inline inquery_ai_question_content_req& operator=(inquery_ai_question_content_req&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const inquery_ai_question_content_req& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const inquery_ai_question_content_req* internal_default_instance() {
    return reinterpret_cast<const inquery_ai_question_content_req*>(
               &_inquery_ai_question_content_req_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  void Swap(inquery_ai_question_content_req* other);
  friend void swap(inquery_ai_question_content_req& a, inquery_ai_question_content_req& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline inquery_ai_question_content_req* New() const final {
    return CreateMaybeMessage<inquery_ai_question_content_req>(NULL);
  }

  inquery_ai_question_content_req* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<inquery_ai_question_content_req>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const inquery_ai_question_content_req& from);
  void MergeFrom(const inquery_ai_question_content_req& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(inquery_ai_question_content_req* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // uint64 standard_question_id = 1;
  void clear_standard_question_id();
  static const int kStandardQuestionIdFieldNumber = 1;
  ::google::protobuf::uint64 standard_question_id() const;
  void set_standard_question_id(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:robot_knowledge.inquery_ai_question_content_req)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint64 standard_question_id_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_robot_5fknowledge_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class inquery_ai_question_content_ack : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:robot_knowledge.inquery_ai_question_content_ack) */ {
 public:
  inquery_ai_question_content_ack();
  virtual ~inquery_ai_question_content_ack();

  inquery_ai_question_content_ack(const inquery_ai_question_content_ack& from);

  inline inquery_ai_question_content_ack& operator=(const inquery_ai_question_content_ack& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  inquery_ai_question_content_ack(inquery_ai_question_content_ack&& from) noexcept
    : inquery_ai_question_content_ack() {
    *this = ::std::move(from);
  }

  inline inquery_ai_question_content_ack& operator=(inquery_ai_question_content_ack&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const inquery_ai_question_content_ack& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const inquery_ai_question_content_ack* internal_default_instance() {
    return reinterpret_cast<const inquery_ai_question_content_ack*>(
               &_inquery_ai_question_content_ack_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  void Swap(inquery_ai_question_content_ack* other);
  friend void swap(inquery_ai_question_content_ack& a, inquery_ai_question_content_ack& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline inquery_ai_question_content_ack* New() const final {
    return CreateMaybeMessage<inquery_ai_question_content_ack>(NULL);
  }

  inquery_ai_question_content_ack* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<inquery_ai_question_content_ack>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const inquery_ai_question_content_ack& from);
  void MergeFrom(const inquery_ai_question_content_ack& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(inquery_ai_question_content_ack* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .common.errorinfo error = 1;
  bool has_error() const;
  void clear_error();
  static const int kErrorFieldNumber = 1;
  private:
  const ::common::errorinfo& _internal_error() const;
  public:
  const ::common::errorinfo& error() const;
  ::common::errorinfo* release_error();
  ::common::errorinfo* mutable_error();
  void set_allocated_error(::common::errorinfo* error);

  // .robot_knowledge.ai_question question_content = 2;
  bool has_question_content() const;
  void clear_question_content();
  static const int kQuestionContentFieldNumber = 2;
  private:
  const ::robot_knowledge::ai_question& _internal_question_content() const;
  public:
  const ::robot_knowledge::ai_question& question_content() const;
  ::robot_knowledge::ai_question* release_question_content();
  ::robot_knowledge::ai_question* mutable_question_content();
  void set_allocated_question_content(::robot_knowledge::ai_question* question_content);

  // @@protoc_insertion_point(class_scope:robot_knowledge.inquery_ai_question_content_ack)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::common::errorinfo* error_;
  ::robot_knowledge::ai_question* question_content_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_robot_5fknowledge_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class edit_ai_question_req : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:robot_knowledge.edit_ai_question_req) */ {
 public:
  edit_ai_question_req();
  virtual ~edit_ai_question_req();

  edit_ai_question_req(const edit_ai_question_req& from);

  inline edit_ai_question_req& operator=(const edit_ai_question_req& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  edit_ai_question_req(edit_ai_question_req&& from) noexcept
    : edit_ai_question_req() {
    *this = ::std::move(from);
  }

  inline edit_ai_question_req& operator=(edit_ai_question_req&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const edit_ai_question_req& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const edit_ai_question_req* internal_default_instance() {
    return reinterpret_cast<const edit_ai_question_req*>(
               &_edit_ai_question_req_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  void Swap(edit_ai_question_req* other);
  friend void swap(edit_ai_question_req& a, edit_ai_question_req& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline edit_ai_question_req* New() const final {
    return CreateMaybeMessage<edit_ai_question_req>(NULL);
  }

  edit_ai_question_req* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<edit_ai_question_req>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const edit_ai_question_req& from);
  void MergeFrom(const edit_ai_question_req& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(edit_ai_question_req* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .robot_knowledge.ai_question question_content = 1;
  bool has_question_content() const;
  void clear_question_content();
  static const int kQuestionContentFieldNumber = 1;
  private:
  const ::robot_knowledge::ai_question& _internal_question_content() const;
  public:
  const ::robot_knowledge::ai_question& question_content() const;
  ::robot_knowledge::ai_question* release_question_content();
  ::robot_knowledge::ai_question* mutable_question_content();
  void set_allocated_question_content(::robot_knowledge::ai_question* question_content);

  // uint32 update_type = 2;
  void clear_update_type();
  static const int kUpdateTypeFieldNumber = 2;
  ::google::protobuf::uint32 update_type() const;
  void set_update_type(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:robot_knowledge.edit_ai_question_req)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::robot_knowledge::ai_question* question_content_;
  ::google::protobuf::uint32 update_type_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_robot_5fknowledge_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class edit_ai_question_ack : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:robot_knowledge.edit_ai_question_ack) */ {
 public:
  edit_ai_question_ack();
  virtual ~edit_ai_question_ack();

  edit_ai_question_ack(const edit_ai_question_ack& from);

  inline edit_ai_question_ack& operator=(const edit_ai_question_ack& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  edit_ai_question_ack(edit_ai_question_ack&& from) noexcept
    : edit_ai_question_ack() {
    *this = ::std::move(from);
  }

  inline edit_ai_question_ack& operator=(edit_ai_question_ack&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const edit_ai_question_ack& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const edit_ai_question_ack* internal_default_instance() {
    return reinterpret_cast<const edit_ai_question_ack*>(
               &_edit_ai_question_ack_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  void Swap(edit_ai_question_ack* other);
  friend void swap(edit_ai_question_ack& a, edit_ai_question_ack& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline edit_ai_question_ack* New() const final {
    return CreateMaybeMessage<edit_ai_question_ack>(NULL);
  }

  edit_ai_question_ack* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<edit_ai_question_ack>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const edit_ai_question_ack& from);
  void MergeFrom(const edit_ai_question_ack& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(edit_ai_question_ack* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .common.errorinfo error = 1;
  bool has_error() const;
  void clear_error();
  static const int kErrorFieldNumber = 1;
  private:
  const ::common::errorinfo& _internal_error() const;
  public:
  const ::common::errorinfo& error() const;
  ::common::errorinfo* release_error();
  ::common::errorinfo* mutable_error();
  void set_allocated_error(::common::errorinfo* error);

  // .robot_knowledge.ai_question question_content = 2;
  bool has_question_content() const;
  void clear_question_content();
  static const int kQuestionContentFieldNumber = 2;
  private:
  const ::robot_knowledge::ai_question& _internal_question_content() const;
  public:
  const ::robot_knowledge::ai_question& question_content() const;
  ::robot_knowledge::ai_question* release_question_content();
  ::robot_knowledge::ai_question* mutable_question_content();
  void set_allocated_question_content(::robot_knowledge::ai_question* question_content);

  // @@protoc_insertion_point(class_scope:robot_knowledge.edit_ai_question_ack)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::common::errorinfo* error_;
  ::robot_knowledge::ai_question* question_content_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_robot_5fknowledge_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// similar_question

// uint64 index_id = 1;
inline void similar_question::clear_index_id() {
  index_id_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 similar_question::index_id() const {
  // @@protoc_insertion_point(field_get:robot_knowledge.similar_question.index_id)
  return index_id_;
}
inline void similar_question::set_index_id(::google::protobuf::uint64 value) {
  
  index_id_ = value;
  // @@protoc_insertion_point(field_set:robot_knowledge.similar_question.index_id)
}

// bytes question = 2;
inline void similar_question::clear_question() {
  question_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& similar_question::question() const {
  // @@protoc_insertion_point(field_get:robot_knowledge.similar_question.question)
  return question_.GetNoArena();
}
inline void similar_question::set_question(const ::std::string& value) {
  
  question_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:robot_knowledge.similar_question.question)
}
#if LANG_CXX11
inline void similar_question::set_question(::std::string&& value) {
  
  question_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:robot_knowledge.similar_question.question)
}
#endif
inline void similar_question::set_question(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  question_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:robot_knowledge.similar_question.question)
}
inline void similar_question::set_question(const void* value, size_t size) {
  
  question_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:robot_knowledge.similar_question.question)
}
inline ::std::string* similar_question::mutable_question() {
  
  // @@protoc_insertion_point(field_mutable:robot_knowledge.similar_question.question)
  return question_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* similar_question::release_question() {
  // @@protoc_insertion_point(field_release:robot_knowledge.similar_question.question)
  
  return question_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void similar_question::set_allocated_question(::std::string* question) {
  if (question != NULL) {
    
  } else {
    
  }
  question_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), question);
  // @@protoc_insertion_point(field_set_allocated:robot_knowledge.similar_question.question)
}

// uint32 create_date = 3;
inline void similar_question::clear_create_date() {
  create_date_ = 0u;
}
inline ::google::protobuf::uint32 similar_question::create_date() const {
  // @@protoc_insertion_point(field_get:robot_knowledge.similar_question.create_date)
  return create_date_;
}
inline void similar_question::set_create_date(::google::protobuf::uint32 value) {
  
  create_date_ = value;
  // @@protoc_insertion_point(field_set:robot_knowledge.similar_question.create_date)
}

// uint32 update_date = 4;
inline void similar_question::clear_update_date() {
  update_date_ = 0u;
}
inline ::google::protobuf::uint32 similar_question::update_date() const {
  // @@protoc_insertion_point(field_get:robot_knowledge.similar_question.update_date)
  return update_date_;
}
inline void similar_question::set_update_date(::google::protobuf::uint32 value) {
  
  update_date_ = value;
  // @@protoc_insertion_point(field_set:robot_knowledge.similar_question.update_date)
}

// -------------------------------------------------------------------

// ai_question

// uint64 index_id = 1;
inline void ai_question::clear_index_id() {
  index_id_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 ai_question::index_id() const {
  // @@protoc_insertion_point(field_get:robot_knowledge.ai_question.index_id)
  return index_id_;
}
inline void ai_question::set_index_id(::google::protobuf::uint64 value) {
  
  index_id_ = value;
  // @@protoc_insertion_point(field_set:robot_knowledge.ai_question.index_id)
}

// uint64 standard_question_id = 2;
inline void ai_question::clear_standard_question_id() {
  standard_question_id_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 ai_question::standard_question_id() const {
  // @@protoc_insertion_point(field_get:robot_knowledge.ai_question.standard_question_id)
  return standard_question_id_;
}
inline void ai_question::set_standard_question_id(::google::protobuf::uint64 value) {
  
  standard_question_id_ = value;
  // @@protoc_insertion_point(field_set:robot_knowledge.ai_question.standard_question_id)
}

// uint32 question_type = 3;
inline void ai_question::clear_question_type() {
  question_type_ = 0u;
}
inline ::google::protobuf::uint32 ai_question::question_type() const {
  // @@protoc_insertion_point(field_get:robot_knowledge.ai_question.question_type)
  return question_type_;
}
inline void ai_question::set_question_type(::google::protobuf::uint32 value) {
  
  question_type_ = value;
  // @@protoc_insertion_point(field_set:robot_knowledge.ai_question.question_type)
}

// bytes question = 4;
inline void ai_question::clear_question() {
  question_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ai_question::question() const {
  // @@protoc_insertion_point(field_get:robot_knowledge.ai_question.question)
  return question_.GetNoArena();
}
inline void ai_question::set_question(const ::std::string& value) {
  
  question_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:robot_knowledge.ai_question.question)
}
#if LANG_CXX11
inline void ai_question::set_question(::std::string&& value) {
  
  question_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:robot_knowledge.ai_question.question)
}
#endif
inline void ai_question::set_question(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  question_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:robot_knowledge.ai_question.question)
}
inline void ai_question::set_question(const void* value, size_t size) {
  
  question_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:robot_knowledge.ai_question.question)
}
inline ::std::string* ai_question::mutable_question() {
  
  // @@protoc_insertion_point(field_mutable:robot_knowledge.ai_question.question)
  return question_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ai_question::release_question() {
  // @@protoc_insertion_point(field_release:robot_knowledge.ai_question.question)
  
  return question_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ai_question::set_allocated_question(::std::string* question) {
  if (question != NULL) {
    
  } else {
    
  }
  question_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), question);
  // @@protoc_insertion_point(field_set_allocated:robot_knowledge.ai_question.question)
}

// bytes answer = 5;
inline void ai_question::clear_answer() {
  answer_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ai_question::answer() const {
  // @@protoc_insertion_point(field_get:robot_knowledge.ai_question.answer)
  return answer_.GetNoArena();
}
inline void ai_question::set_answer(const ::std::string& value) {
  
  answer_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:robot_knowledge.ai_question.answer)
}
#if LANG_CXX11
inline void ai_question::set_answer(::std::string&& value) {
  
  answer_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:robot_knowledge.ai_question.answer)
}
#endif
inline void ai_question::set_answer(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  answer_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:robot_knowledge.ai_question.answer)
}
inline void ai_question::set_answer(const void* value, size_t size) {
  
  answer_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:robot_knowledge.ai_question.answer)
}
inline ::std::string* ai_question::mutable_answer() {
  
  // @@protoc_insertion_point(field_mutable:robot_knowledge.ai_question.answer)
  return answer_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ai_question::release_answer() {
  // @@protoc_insertion_point(field_release:robot_knowledge.ai_question.answer)
  
  return answer_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ai_question::set_allocated_answer(::std::string* answer) {
  if (answer != NULL) {
    
  } else {
    
  }
  answer_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), answer);
  // @@protoc_insertion_point(field_set_allocated:robot_knowledge.ai_question.answer)
}

// uint32 create_date = 6;
inline void ai_question::clear_create_date() {
  create_date_ = 0u;
}
inline ::google::protobuf::uint32 ai_question::create_date() const {
  // @@protoc_insertion_point(field_get:robot_knowledge.ai_question.create_date)
  return create_date_;
}
inline void ai_question::set_create_date(::google::protobuf::uint32 value) {
  
  create_date_ = value;
  // @@protoc_insertion_point(field_set:robot_knowledge.ai_question.create_date)
}

// uint32 update_date = 7;
inline void ai_question::clear_update_date() {
  update_date_ = 0u;
}
inline ::google::protobuf::uint32 ai_question::update_date() const {
  // @@protoc_insertion_point(field_get:robot_knowledge.ai_question.update_date)
  return update_date_;
}
inline void ai_question::set_update_date(::google::protobuf::uint32 value) {
  
  update_date_ = value;
  // @@protoc_insertion_point(field_set:robot_knowledge.ai_question.update_date)
}

// repeated .robot_knowledge.similar_question similar_questions_list = 8;
inline int ai_question::similar_questions_list_size() const {
  return similar_questions_list_.size();
}
inline void ai_question::clear_similar_questions_list() {
  similar_questions_list_.Clear();
}
inline ::robot_knowledge::similar_question* ai_question::mutable_similar_questions_list(int index) {
  // @@protoc_insertion_point(field_mutable:robot_knowledge.ai_question.similar_questions_list)
  return similar_questions_list_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::robot_knowledge::similar_question >*
ai_question::mutable_similar_questions_list() {
  // @@protoc_insertion_point(field_mutable_list:robot_knowledge.ai_question.similar_questions_list)
  return &similar_questions_list_;
}
inline const ::robot_knowledge::similar_question& ai_question::similar_questions_list(int index) const {
  // @@protoc_insertion_point(field_get:robot_knowledge.ai_question.similar_questions_list)
  return similar_questions_list_.Get(index);
}
inline ::robot_knowledge::similar_question* ai_question::add_similar_questions_list() {
  // @@protoc_insertion_point(field_add:robot_knowledge.ai_question.similar_questions_list)
  return similar_questions_list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::robot_knowledge::similar_question >&
ai_question::similar_questions_list() const {
  // @@protoc_insertion_point(field_list:robot_knowledge.ai_question.similar_questions_list)
  return similar_questions_list_;
}

// -------------------------------------------------------------------

// get_ai_question_list_req

// uint32 question_type = 1;
inline void get_ai_question_list_req::clear_question_type() {
  question_type_ = 0u;
}
inline ::google::protobuf::uint32 get_ai_question_list_req::question_type() const {
  // @@protoc_insertion_point(field_get:robot_knowledge.get_ai_question_list_req.question_type)
  return question_type_;
}
inline void get_ai_question_list_req::set_question_type(::google::protobuf::uint32 value) {
  
  question_type_ = value;
  // @@protoc_insertion_point(field_set:robot_knowledge.get_ai_question_list_req.question_type)
}

// uint32 page = 2;
inline void get_ai_question_list_req::clear_page() {
  page_ = 0u;
}
inline ::google::protobuf::uint32 get_ai_question_list_req::page() const {
  // @@protoc_insertion_point(field_get:robot_knowledge.get_ai_question_list_req.page)
  return page_;
}
inline void get_ai_question_list_req::set_page(::google::protobuf::uint32 value) {
  
  page_ = value;
  // @@protoc_insertion_point(field_set:robot_knowledge.get_ai_question_list_req.page)
}

// -------------------------------------------------------------------

// get_ai_question_list_ack

// .common.errorinfo error = 1;
inline bool get_ai_question_list_ack::has_error() const {
  return this != internal_default_instance() && error_ != NULL;
}
inline const ::common::errorinfo& get_ai_question_list_ack::_internal_error() const {
  return *error_;
}
inline const ::common::errorinfo& get_ai_question_list_ack::error() const {
  const ::common::errorinfo* p = error_;
  // @@protoc_insertion_point(field_get:robot_knowledge.get_ai_question_list_ack.error)
  return p != NULL ? *p : *reinterpret_cast<const ::common::errorinfo*>(
      &::common::_errorinfo_default_instance_);
}
inline ::common::errorinfo* get_ai_question_list_ack::release_error() {
  // @@protoc_insertion_point(field_release:robot_knowledge.get_ai_question_list_ack.error)
  
  ::common::errorinfo* temp = error_;
  error_ = NULL;
  return temp;
}
inline ::common::errorinfo* get_ai_question_list_ack::mutable_error() {
  
  if (error_ == NULL) {
    auto* p = CreateMaybeMessage<::common::errorinfo>(GetArenaNoVirtual());
    error_ = p;
  }
  // @@protoc_insertion_point(field_mutable:robot_knowledge.get_ai_question_list_ack.error)
  return error_;
}
inline void get_ai_question_list_ack::set_allocated_error(::common::errorinfo* error) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(error_);
  }
  if (error) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      error = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, error, submessage_arena);
    }
    
  } else {
    
  }
  error_ = error;
  // @@protoc_insertion_point(field_set_allocated:robot_knowledge.get_ai_question_list_ack.error)
}

// repeated .robot_knowledge.ai_question ai_question_list = 2;
inline int get_ai_question_list_ack::ai_question_list_size() const {
  return ai_question_list_.size();
}
inline void get_ai_question_list_ack::clear_ai_question_list() {
  ai_question_list_.Clear();
}
inline ::robot_knowledge::ai_question* get_ai_question_list_ack::mutable_ai_question_list(int index) {
  // @@protoc_insertion_point(field_mutable:robot_knowledge.get_ai_question_list_ack.ai_question_list)
  return ai_question_list_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::robot_knowledge::ai_question >*
get_ai_question_list_ack::mutable_ai_question_list() {
  // @@protoc_insertion_point(field_mutable_list:robot_knowledge.get_ai_question_list_ack.ai_question_list)
  return &ai_question_list_;
}
inline const ::robot_knowledge::ai_question& get_ai_question_list_ack::ai_question_list(int index) const {
  // @@protoc_insertion_point(field_get:robot_knowledge.get_ai_question_list_ack.ai_question_list)
  return ai_question_list_.Get(index);
}
inline ::robot_knowledge::ai_question* get_ai_question_list_ack::add_ai_question_list() {
  // @@protoc_insertion_point(field_add:robot_knowledge.get_ai_question_list_ack.ai_question_list)
  return ai_question_list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::robot_knowledge::ai_question >&
get_ai_question_list_ack::ai_question_list() const {
  // @@protoc_insertion_point(field_list:robot_knowledge.get_ai_question_list_ack.ai_question_list)
  return ai_question_list_;
}

// uint32 total_num = 3;
inline void get_ai_question_list_ack::clear_total_num() {
  total_num_ = 0u;
}
inline ::google::protobuf::uint32 get_ai_question_list_ack::total_num() const {
  // @@protoc_insertion_point(field_get:robot_knowledge.get_ai_question_list_ack.total_num)
  return total_num_;
}
inline void get_ai_question_list_ack::set_total_num(::google::protobuf::uint32 value) {
  
  total_num_ = value;
  // @@protoc_insertion_point(field_set:robot_knowledge.get_ai_question_list_ack.total_num)
}

// -------------------------------------------------------------------

// inquery_ai_question_content_req

// uint64 standard_question_id = 1;
inline void inquery_ai_question_content_req::clear_standard_question_id() {
  standard_question_id_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 inquery_ai_question_content_req::standard_question_id() const {
  // @@protoc_insertion_point(field_get:robot_knowledge.inquery_ai_question_content_req.standard_question_id)
  return standard_question_id_;
}
inline void inquery_ai_question_content_req::set_standard_question_id(::google::protobuf::uint64 value) {
  
  standard_question_id_ = value;
  // @@protoc_insertion_point(field_set:robot_knowledge.inquery_ai_question_content_req.standard_question_id)
}

// -------------------------------------------------------------------

// inquery_ai_question_content_ack

// .common.errorinfo error = 1;
inline bool inquery_ai_question_content_ack::has_error() const {
  return this != internal_default_instance() && error_ != NULL;
}
inline const ::common::errorinfo& inquery_ai_question_content_ack::_internal_error() const {
  return *error_;
}
inline const ::common::errorinfo& inquery_ai_question_content_ack::error() const {
  const ::common::errorinfo* p = error_;
  // @@protoc_insertion_point(field_get:robot_knowledge.inquery_ai_question_content_ack.error)
  return p != NULL ? *p : *reinterpret_cast<const ::common::errorinfo*>(
      &::common::_errorinfo_default_instance_);
}
inline ::common::errorinfo* inquery_ai_question_content_ack::release_error() {
  // @@protoc_insertion_point(field_release:robot_knowledge.inquery_ai_question_content_ack.error)
  
  ::common::errorinfo* temp = error_;
  error_ = NULL;
  return temp;
}
inline ::common::errorinfo* inquery_ai_question_content_ack::mutable_error() {
  
  if (error_ == NULL) {
    auto* p = CreateMaybeMessage<::common::errorinfo>(GetArenaNoVirtual());
    error_ = p;
  }
  // @@protoc_insertion_point(field_mutable:robot_knowledge.inquery_ai_question_content_ack.error)
  return error_;
}
inline void inquery_ai_question_content_ack::set_allocated_error(::common::errorinfo* error) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(error_);
  }
  if (error) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      error = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, error, submessage_arena);
    }
    
  } else {
    
  }
  error_ = error;
  // @@protoc_insertion_point(field_set_allocated:robot_knowledge.inquery_ai_question_content_ack.error)
}

// .robot_knowledge.ai_question question_content = 2;
inline bool inquery_ai_question_content_ack::has_question_content() const {
  return this != internal_default_instance() && question_content_ != NULL;
}
inline void inquery_ai_question_content_ack::clear_question_content() {
  if (GetArenaNoVirtual() == NULL && question_content_ != NULL) {
    delete question_content_;
  }
  question_content_ = NULL;
}
inline const ::robot_knowledge::ai_question& inquery_ai_question_content_ack::_internal_question_content() const {
  return *question_content_;
}
inline const ::robot_knowledge::ai_question& inquery_ai_question_content_ack::question_content() const {
  const ::robot_knowledge::ai_question* p = question_content_;
  // @@protoc_insertion_point(field_get:robot_knowledge.inquery_ai_question_content_ack.question_content)
  return p != NULL ? *p : *reinterpret_cast<const ::robot_knowledge::ai_question*>(
      &::robot_knowledge::_ai_question_default_instance_);
}
inline ::robot_knowledge::ai_question* inquery_ai_question_content_ack::release_question_content() {
  // @@protoc_insertion_point(field_release:robot_knowledge.inquery_ai_question_content_ack.question_content)
  
  ::robot_knowledge::ai_question* temp = question_content_;
  question_content_ = NULL;
  return temp;
}
inline ::robot_knowledge::ai_question* inquery_ai_question_content_ack::mutable_question_content() {
  
  if (question_content_ == NULL) {
    auto* p = CreateMaybeMessage<::robot_knowledge::ai_question>(GetArenaNoVirtual());
    question_content_ = p;
  }
  // @@protoc_insertion_point(field_mutable:robot_knowledge.inquery_ai_question_content_ack.question_content)
  return question_content_;
}
inline void inquery_ai_question_content_ack::set_allocated_question_content(::robot_knowledge::ai_question* question_content) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete question_content_;
  }
  if (question_content) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      question_content = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, question_content, submessage_arena);
    }
    
  } else {
    
  }
  question_content_ = question_content;
  // @@protoc_insertion_point(field_set_allocated:robot_knowledge.inquery_ai_question_content_ack.question_content)
}

// -------------------------------------------------------------------

// edit_ai_question_req

// .robot_knowledge.ai_question question_content = 1;
inline bool edit_ai_question_req::has_question_content() const {
  return this != internal_default_instance() && question_content_ != NULL;
}
inline void edit_ai_question_req::clear_question_content() {
  if (GetArenaNoVirtual() == NULL && question_content_ != NULL) {
    delete question_content_;
  }
  question_content_ = NULL;
}
inline const ::robot_knowledge::ai_question& edit_ai_question_req::_internal_question_content() const {
  return *question_content_;
}
inline const ::robot_knowledge::ai_question& edit_ai_question_req::question_content() const {
  const ::robot_knowledge::ai_question* p = question_content_;
  // @@protoc_insertion_point(field_get:robot_knowledge.edit_ai_question_req.question_content)
  return p != NULL ? *p : *reinterpret_cast<const ::robot_knowledge::ai_question*>(
      &::robot_knowledge::_ai_question_default_instance_);
}
inline ::robot_knowledge::ai_question* edit_ai_question_req::release_question_content() {
  // @@protoc_insertion_point(field_release:robot_knowledge.edit_ai_question_req.question_content)
  
  ::robot_knowledge::ai_question* temp = question_content_;
  question_content_ = NULL;
  return temp;
}
inline ::robot_knowledge::ai_question* edit_ai_question_req::mutable_question_content() {
  
  if (question_content_ == NULL) {
    auto* p = CreateMaybeMessage<::robot_knowledge::ai_question>(GetArenaNoVirtual());
    question_content_ = p;
  }
  // @@protoc_insertion_point(field_mutable:robot_knowledge.edit_ai_question_req.question_content)
  return question_content_;
}
inline void edit_ai_question_req::set_allocated_question_content(::robot_knowledge::ai_question* question_content) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete question_content_;
  }
  if (question_content) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      question_content = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, question_content, submessage_arena);
    }
    
  } else {
    
  }
  question_content_ = question_content;
  // @@protoc_insertion_point(field_set_allocated:robot_knowledge.edit_ai_question_req.question_content)
}

// uint32 update_type = 2;
inline void edit_ai_question_req::clear_update_type() {
  update_type_ = 0u;
}
inline ::google::protobuf::uint32 edit_ai_question_req::update_type() const {
  // @@protoc_insertion_point(field_get:robot_knowledge.edit_ai_question_req.update_type)
  return update_type_;
}
inline void edit_ai_question_req::set_update_type(::google::protobuf::uint32 value) {
  
  update_type_ = value;
  // @@protoc_insertion_point(field_set:robot_knowledge.edit_ai_question_req.update_type)
}

// -------------------------------------------------------------------

// edit_ai_question_ack

// .common.errorinfo error = 1;
inline bool edit_ai_question_ack::has_error() const {
  return this != internal_default_instance() && error_ != NULL;
}
inline const ::common::errorinfo& edit_ai_question_ack::_internal_error() const {
  return *error_;
}
inline const ::common::errorinfo& edit_ai_question_ack::error() const {
  const ::common::errorinfo* p = error_;
  // @@protoc_insertion_point(field_get:robot_knowledge.edit_ai_question_ack.error)
  return p != NULL ? *p : *reinterpret_cast<const ::common::errorinfo*>(
      &::common::_errorinfo_default_instance_);
}
inline ::common::errorinfo* edit_ai_question_ack::release_error() {
  // @@protoc_insertion_point(field_release:robot_knowledge.edit_ai_question_ack.error)
  
  ::common::errorinfo* temp = error_;
  error_ = NULL;
  return temp;
}
inline ::common::errorinfo* edit_ai_question_ack::mutable_error() {
  
  if (error_ == NULL) {
    auto* p = CreateMaybeMessage<::common::errorinfo>(GetArenaNoVirtual());
    error_ = p;
  }
  // @@protoc_insertion_point(field_mutable:robot_knowledge.edit_ai_question_ack.error)
  return error_;
}
inline void edit_ai_question_ack::set_allocated_error(::common::errorinfo* error) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(error_);
  }
  if (error) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      error = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, error, submessage_arena);
    }
    
  } else {
    
  }
  error_ = error;
  // @@protoc_insertion_point(field_set_allocated:robot_knowledge.edit_ai_question_ack.error)
}

// .robot_knowledge.ai_question question_content = 2;
inline bool edit_ai_question_ack::has_question_content() const {
  return this != internal_default_instance() && question_content_ != NULL;
}
inline void edit_ai_question_ack::clear_question_content() {
  if (GetArenaNoVirtual() == NULL && question_content_ != NULL) {
    delete question_content_;
  }
  question_content_ = NULL;
}
inline const ::robot_knowledge::ai_question& edit_ai_question_ack::_internal_question_content() const {
  return *question_content_;
}
inline const ::robot_knowledge::ai_question& edit_ai_question_ack::question_content() const {
  const ::robot_knowledge::ai_question* p = question_content_;
  // @@protoc_insertion_point(field_get:robot_knowledge.edit_ai_question_ack.question_content)
  return p != NULL ? *p : *reinterpret_cast<const ::robot_knowledge::ai_question*>(
      &::robot_knowledge::_ai_question_default_instance_);
}
inline ::robot_knowledge::ai_question* edit_ai_question_ack::release_question_content() {
  // @@protoc_insertion_point(field_release:robot_knowledge.edit_ai_question_ack.question_content)
  
  ::robot_knowledge::ai_question* temp = question_content_;
  question_content_ = NULL;
  return temp;
}
inline ::robot_knowledge::ai_question* edit_ai_question_ack::mutable_question_content() {
  
  if (question_content_ == NULL) {
    auto* p = CreateMaybeMessage<::robot_knowledge::ai_question>(GetArenaNoVirtual());
    question_content_ = p;
  }
  // @@protoc_insertion_point(field_mutable:robot_knowledge.edit_ai_question_ack.question_content)
  return question_content_;
}
inline void edit_ai_question_ack::set_allocated_question_content(::robot_knowledge::ai_question* question_content) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete question_content_;
  }
  if (question_content) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      question_content = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, question_content, submessage_arena);
    }
    
  } else {
    
  }
  question_content_ = question_content;
  // @@protoc_insertion_point(field_set_allocated:robot_knowledge.edit_ai_question_ack.question_content)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace robot_knowledge

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_INCLUDED_robot_5fknowledge_2eproto
