// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: dataproxy.proto

#ifndef PROTOBUF_INCLUDED_dataproxy_2eproto
#define PROTOBUF_INCLUDED_dataproxy_2eproto

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3006001
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#define PROTOBUF_INTERNAL_EXPORT_protobuf_dataproxy_2eproto 

namespace protobuf_dataproxy_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[10];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
}  // namespace protobuf_dataproxy_2eproto
namespace DataMem {
class Field;
class FieldDefaultTypeInternal;
extern FieldDefaultTypeInternal _Field_default_instance_;
class MemOperate;
class MemOperateDefaultTypeInternal;
extern MemOperateDefaultTypeInternal _MemOperate_default_instance_;
class MemOperate_DbOperate;
class MemOperate_DbOperateDefaultTypeInternal;
extern MemOperate_DbOperateDefaultTypeInternal _MemOperate_DbOperate_default_instance_;
class MemOperate_DbOperate_Condition;
class MemOperate_DbOperate_ConditionDefaultTypeInternal;
extern MemOperate_DbOperate_ConditionDefaultTypeInternal _MemOperate_DbOperate_Condition_default_instance_;
class MemOperate_DbOperate_ConditionGroup;
class MemOperate_DbOperate_ConditionGroupDefaultTypeInternal;
extern MemOperate_DbOperate_ConditionGroupDefaultTypeInternal _MemOperate_DbOperate_ConditionGroup_default_instance_;
class MemOperate_DbOperate_OrderBy;
class MemOperate_DbOperate_OrderByDefaultTypeInternal;
extern MemOperate_DbOperate_OrderByDefaultTypeInternal _MemOperate_DbOperate_OrderBy_default_instance_;
class MemOperate_RedisOperate;
class MemOperate_RedisOperateDefaultTypeInternal;
extern MemOperate_RedisOperateDefaultTypeInternal _MemOperate_RedisOperate_default_instance_;
class MemRsp;
class MemRspDefaultTypeInternal;
extern MemRspDefaultTypeInternal _MemRsp_default_instance_;
class MemRsp_DataLocate;
class MemRsp_DataLocateDefaultTypeInternal;
extern MemRsp_DataLocateDefaultTypeInternal _MemRsp_DataLocate_default_instance_;
class Record;
class RecordDefaultTypeInternal;
extern RecordDefaultTypeInternal _Record_default_instance_;
}  // namespace DataMem
namespace google {
namespace protobuf {
template<> ::DataMem::Field* Arena::CreateMaybeMessage<::DataMem::Field>(Arena*);
template<> ::DataMem::MemOperate* Arena::CreateMaybeMessage<::DataMem::MemOperate>(Arena*);
template<> ::DataMem::MemOperate_DbOperate* Arena::CreateMaybeMessage<::DataMem::MemOperate_DbOperate>(Arena*);
template<> ::DataMem::MemOperate_DbOperate_Condition* Arena::CreateMaybeMessage<::DataMem::MemOperate_DbOperate_Condition>(Arena*);
template<> ::DataMem::MemOperate_DbOperate_ConditionGroup* Arena::CreateMaybeMessage<::DataMem::MemOperate_DbOperate_ConditionGroup>(Arena*);
template<> ::DataMem::MemOperate_DbOperate_OrderBy* Arena::CreateMaybeMessage<::DataMem::MemOperate_DbOperate_OrderBy>(Arena*);
template<> ::DataMem::MemOperate_RedisOperate* Arena::CreateMaybeMessage<::DataMem::MemOperate_RedisOperate>(Arena*);
template<> ::DataMem::MemRsp* Arena::CreateMaybeMessage<::DataMem::MemRsp>(Arena*);
template<> ::DataMem::MemRsp_DataLocate* Arena::CreateMaybeMessage<::DataMem::MemRsp_DataLocate>(Arena*);
template<> ::DataMem::Record* Arena::CreateMaybeMessage<::DataMem::Record>(Arena*);
}  // namespace protobuf
}  // namespace google
namespace DataMem {

enum MemOperate_RedisOperate_OPERATE_TYPE {
  MemOperate_RedisOperate_OPERATE_TYPE_OPERATE_TYPE_UNKNOWN = 0,
  MemOperate_RedisOperate_OPERATE_TYPE_T_READ = 1,
  MemOperate_RedisOperate_OPERATE_TYPE_T_WRITE = 2
};
bool MemOperate_RedisOperate_OPERATE_TYPE_IsValid(int value);
const MemOperate_RedisOperate_OPERATE_TYPE MemOperate_RedisOperate_OPERATE_TYPE_OPERATE_TYPE_MIN = MemOperate_RedisOperate_OPERATE_TYPE_OPERATE_TYPE_UNKNOWN;
const MemOperate_RedisOperate_OPERATE_TYPE MemOperate_RedisOperate_OPERATE_TYPE_OPERATE_TYPE_MAX = MemOperate_RedisOperate_OPERATE_TYPE_T_WRITE;
const int MemOperate_RedisOperate_OPERATE_TYPE_OPERATE_TYPE_ARRAYSIZE = MemOperate_RedisOperate_OPERATE_TYPE_OPERATE_TYPE_MAX + 1;

const ::google::protobuf::EnumDescriptor* MemOperate_RedisOperate_OPERATE_TYPE_descriptor();
inline const ::std::string& MemOperate_RedisOperate_OPERATE_TYPE_Name(MemOperate_RedisOperate_OPERATE_TYPE value) {
  return ::google::protobuf::internal::NameOfEnum(
    MemOperate_RedisOperate_OPERATE_TYPE_descriptor(), value);
}
inline bool MemOperate_RedisOperate_OPERATE_TYPE_Parse(
    const ::std::string& name, MemOperate_RedisOperate_OPERATE_TYPE* value) {
  return ::google::protobuf::internal::ParseNamedEnum<MemOperate_RedisOperate_OPERATE_TYPE>(
    MemOperate_RedisOperate_OPERATE_TYPE_descriptor(), name, value);
}
enum MemOperate_DbOperate_Condition_E_RELATION {
  MemOperate_DbOperate_Condition_E_RELATION_E_RELATION_UNKNOWN = 0,
  MemOperate_DbOperate_Condition_E_RELATION_EQ = 1,
  MemOperate_DbOperate_Condition_E_RELATION_NE = 2,
  MemOperate_DbOperate_Condition_E_RELATION_GT = 3,
  MemOperate_DbOperate_Condition_E_RELATION_LT = 4,
  MemOperate_DbOperate_Condition_E_RELATION_GE = 5,
  MemOperate_DbOperate_Condition_E_RELATION_LE = 6,
  MemOperate_DbOperate_Condition_E_RELATION_LIKE = 7,
  MemOperate_DbOperate_Condition_E_RELATION_IN = 8
};
bool MemOperate_DbOperate_Condition_E_RELATION_IsValid(int value);
const MemOperate_DbOperate_Condition_E_RELATION MemOperate_DbOperate_Condition_E_RELATION_E_RELATION_MIN = MemOperate_DbOperate_Condition_E_RELATION_E_RELATION_UNKNOWN;
const MemOperate_DbOperate_Condition_E_RELATION MemOperate_DbOperate_Condition_E_RELATION_E_RELATION_MAX = MemOperate_DbOperate_Condition_E_RELATION_IN;
const int MemOperate_DbOperate_Condition_E_RELATION_E_RELATION_ARRAYSIZE = MemOperate_DbOperate_Condition_E_RELATION_E_RELATION_MAX + 1;

const ::google::protobuf::EnumDescriptor* MemOperate_DbOperate_Condition_E_RELATION_descriptor();
inline const ::std::string& MemOperate_DbOperate_Condition_E_RELATION_Name(MemOperate_DbOperate_Condition_E_RELATION value) {
  return ::google::protobuf::internal::NameOfEnum(
    MemOperate_DbOperate_Condition_E_RELATION_descriptor(), value);
}
inline bool MemOperate_DbOperate_Condition_E_RELATION_Parse(
    const ::std::string& name, MemOperate_DbOperate_Condition_E_RELATION* value) {
  return ::google::protobuf::internal::ParseNamedEnum<MemOperate_DbOperate_Condition_E_RELATION>(
    MemOperate_DbOperate_Condition_E_RELATION_descriptor(), name, value);
}
enum MemOperate_DbOperate_ConditionGroup_E_RELATION {
  MemOperate_DbOperate_ConditionGroup_E_RELATION_E_RELATION_UNKNOWN = 0,
  MemOperate_DbOperate_ConditionGroup_E_RELATION_AND = 1,
  MemOperate_DbOperate_ConditionGroup_E_RELATION_OR = 2
};
bool MemOperate_DbOperate_ConditionGroup_E_RELATION_IsValid(int value);
const MemOperate_DbOperate_ConditionGroup_E_RELATION MemOperate_DbOperate_ConditionGroup_E_RELATION_E_RELATION_MIN = MemOperate_DbOperate_ConditionGroup_E_RELATION_E_RELATION_UNKNOWN;
const MemOperate_DbOperate_ConditionGroup_E_RELATION MemOperate_DbOperate_ConditionGroup_E_RELATION_E_RELATION_MAX = MemOperate_DbOperate_ConditionGroup_E_RELATION_OR;
const int MemOperate_DbOperate_ConditionGroup_E_RELATION_E_RELATION_ARRAYSIZE = MemOperate_DbOperate_ConditionGroup_E_RELATION_E_RELATION_MAX + 1;

const ::google::protobuf::EnumDescriptor* MemOperate_DbOperate_ConditionGroup_E_RELATION_descriptor();
inline const ::std::string& MemOperate_DbOperate_ConditionGroup_E_RELATION_Name(MemOperate_DbOperate_ConditionGroup_E_RELATION value) {
  return ::google::protobuf::internal::NameOfEnum(
    MemOperate_DbOperate_ConditionGroup_E_RELATION_descriptor(), value);
}
inline bool MemOperate_DbOperate_ConditionGroup_E_RELATION_Parse(
    const ::std::string& name, MemOperate_DbOperate_ConditionGroup_E_RELATION* value) {
  return ::google::protobuf::internal::ParseNamedEnum<MemOperate_DbOperate_ConditionGroup_E_RELATION>(
    MemOperate_DbOperate_ConditionGroup_E_RELATION_descriptor(), name, value);
}
enum MemOperate_DbOperate_OrderBy_E_RELATION {
  MemOperate_DbOperate_OrderBy_E_RELATION_E_RELATION_UNKNOWN = 0,
  MemOperate_DbOperate_OrderBy_E_RELATION_ASC = 1,
  MemOperate_DbOperate_OrderBy_E_RELATION_DESC = 2
};
bool MemOperate_DbOperate_OrderBy_E_RELATION_IsValid(int value);
const MemOperate_DbOperate_OrderBy_E_RELATION MemOperate_DbOperate_OrderBy_E_RELATION_E_RELATION_MIN = MemOperate_DbOperate_OrderBy_E_RELATION_E_RELATION_UNKNOWN;
const MemOperate_DbOperate_OrderBy_E_RELATION MemOperate_DbOperate_OrderBy_E_RELATION_E_RELATION_MAX = MemOperate_DbOperate_OrderBy_E_RELATION_DESC;
const int MemOperate_DbOperate_OrderBy_E_RELATION_E_RELATION_ARRAYSIZE = MemOperate_DbOperate_OrderBy_E_RELATION_E_RELATION_MAX + 1;

const ::google::protobuf::EnumDescriptor* MemOperate_DbOperate_OrderBy_E_RELATION_descriptor();
inline const ::std::string& MemOperate_DbOperate_OrderBy_E_RELATION_Name(MemOperate_DbOperate_OrderBy_E_RELATION value) {
  return ::google::protobuf::internal::NameOfEnum(
    MemOperate_DbOperate_OrderBy_E_RELATION_descriptor(), value);
}
inline bool MemOperate_DbOperate_OrderBy_E_RELATION_Parse(
    const ::std::string& name, MemOperate_DbOperate_OrderBy_E_RELATION* value) {
  return ::google::protobuf::internal::ParseNamedEnum<MemOperate_DbOperate_OrderBy_E_RELATION>(
    MemOperate_DbOperate_OrderBy_E_RELATION_descriptor(), name, value);
}
enum MemOperate_DbOperate_E_QUERY_TYPE {
  MemOperate_DbOperate_E_QUERY_TYPE_E_QUERY_TYPE_UNKNONW = 0,
  MemOperate_DbOperate_E_QUERY_TYPE_SELECT = 1,
  MemOperate_DbOperate_E_QUERY_TYPE_INSERT = 2,
  MemOperate_DbOperate_E_QUERY_TYPE_INSERT_IGNORE = 3,
  MemOperate_DbOperate_E_QUERY_TYPE_UPDATE = 4,
  MemOperate_DbOperate_E_QUERY_TYPE_REPLACE = 5,
  MemOperate_DbOperate_E_QUERY_TYPE_DELETE = 6,
  MemOperate_DbOperate_E_QUERY_TYPE_CUSTOM = 7,
  MemOperate_DbOperate_E_QUERY_TYPE_BULK = 8
};
bool MemOperate_DbOperate_E_QUERY_TYPE_IsValid(int value);
const MemOperate_DbOperate_E_QUERY_TYPE MemOperate_DbOperate_E_QUERY_TYPE_E_QUERY_TYPE_MIN = MemOperate_DbOperate_E_QUERY_TYPE_E_QUERY_TYPE_UNKNONW;
const MemOperate_DbOperate_E_QUERY_TYPE MemOperate_DbOperate_E_QUERY_TYPE_E_QUERY_TYPE_MAX = MemOperate_DbOperate_E_QUERY_TYPE_BULK;
const int MemOperate_DbOperate_E_QUERY_TYPE_E_QUERY_TYPE_ARRAYSIZE = MemOperate_DbOperate_E_QUERY_TYPE_E_QUERY_TYPE_MAX + 1;

const ::google::protobuf::EnumDescriptor* MemOperate_DbOperate_E_QUERY_TYPE_descriptor();
inline const ::std::string& MemOperate_DbOperate_E_QUERY_TYPE_Name(MemOperate_DbOperate_E_QUERY_TYPE value) {
  return ::google::protobuf::internal::NameOfEnum(
    MemOperate_DbOperate_E_QUERY_TYPE_descriptor(), value);
}
inline bool MemOperate_DbOperate_E_QUERY_TYPE_Parse(
    const ::std::string& name, MemOperate_DbOperate_E_QUERY_TYPE* value) {
  return ::google::protobuf::internal::ParseNamedEnum<MemOperate_DbOperate_E_QUERY_TYPE>(
    MemOperate_DbOperate_E_QUERY_TYPE_descriptor(), name, value);
}
enum MemRsp_E_RESULT_FROM {
  MemRsp_E_RESULT_FROM_E_RESULT_FROM_UNKNOWN = 0,
  MemRsp_E_RESULT_FROM_FROM_REDIS = 1,
  MemRsp_E_RESULT_FROM_FROM_DB = 2
};
bool MemRsp_E_RESULT_FROM_IsValid(int value);
const MemRsp_E_RESULT_FROM MemRsp_E_RESULT_FROM_E_RESULT_FROM_MIN = MemRsp_E_RESULT_FROM_E_RESULT_FROM_UNKNOWN;
const MemRsp_E_RESULT_FROM MemRsp_E_RESULT_FROM_E_RESULT_FROM_MAX = MemRsp_E_RESULT_FROM_FROM_DB;
const int MemRsp_E_RESULT_FROM_E_RESULT_FROM_ARRAYSIZE = MemRsp_E_RESULT_FROM_E_RESULT_FROM_MAX + 1;

const ::google::protobuf::EnumDescriptor* MemRsp_E_RESULT_FROM_descriptor();
inline const ::std::string& MemRsp_E_RESULT_FROM_Name(MemRsp_E_RESULT_FROM value) {
  return ::google::protobuf::internal::NameOfEnum(
    MemRsp_E_RESULT_FROM_descriptor(), value);
}
inline bool MemRsp_E_RESULT_FROM_Parse(
    const ::std::string& name, MemRsp_E_RESULT_FROM* value) {
  return ::google::protobuf::internal::ParseNamedEnum<MemRsp_E_RESULT_FROM>(
    MemRsp_E_RESULT_FROM_descriptor(), name, value);
}
enum E_COL_TYPE {
  STRING = 0,
  INT = 1,
  BIGINT = 2,
  FLOAT = 3,
  DOUBLE = 4
};
bool E_COL_TYPE_IsValid(int value);
const E_COL_TYPE E_COL_TYPE_MIN = STRING;
const E_COL_TYPE E_COL_TYPE_MAX = DOUBLE;
const int E_COL_TYPE_ARRAYSIZE = E_COL_TYPE_MAX + 1;

const ::google::protobuf::EnumDescriptor* E_COL_TYPE_descriptor();
inline const ::std::string& E_COL_TYPE_Name(E_COL_TYPE value) {
  return ::google::protobuf::internal::NameOfEnum(
    E_COL_TYPE_descriptor(), value);
}
inline bool E_COL_TYPE_Parse(
    const ::std::string& name, E_COL_TYPE* value) {
  return ::google::protobuf::internal::ParseNamedEnum<E_COL_TYPE>(
    E_COL_TYPE_descriptor(), name, value);
}
// ===================================================================

class MemOperate_RedisOperate : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:DataMem.MemOperate.RedisOperate) */ {
 public:
  MemOperate_RedisOperate();
  virtual ~MemOperate_RedisOperate();

  MemOperate_RedisOperate(const MemOperate_RedisOperate& from);

  inline MemOperate_RedisOperate& operator=(const MemOperate_RedisOperate& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MemOperate_RedisOperate(MemOperate_RedisOperate&& from) noexcept
    : MemOperate_RedisOperate() {
    *this = ::std::move(from);
  }

  inline MemOperate_RedisOperate& operator=(MemOperate_RedisOperate&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MemOperate_RedisOperate& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MemOperate_RedisOperate* internal_default_instance() {
    return reinterpret_cast<const MemOperate_RedisOperate*>(
               &_MemOperate_RedisOperate_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(MemOperate_RedisOperate* other);
  friend void swap(MemOperate_RedisOperate& a, MemOperate_RedisOperate& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MemOperate_RedisOperate* New() const final {
    return CreateMaybeMessage<MemOperate_RedisOperate>(NULL);
  }

  MemOperate_RedisOperate* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<MemOperate_RedisOperate>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const MemOperate_RedisOperate& from);
  void MergeFrom(const MemOperate_RedisOperate& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MemOperate_RedisOperate* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef MemOperate_RedisOperate_OPERATE_TYPE OPERATE_TYPE;
  static const OPERATE_TYPE OPERATE_TYPE_UNKNOWN =
    MemOperate_RedisOperate_OPERATE_TYPE_OPERATE_TYPE_UNKNOWN;
  static const OPERATE_TYPE T_READ =
    MemOperate_RedisOperate_OPERATE_TYPE_T_READ;
  static const OPERATE_TYPE T_WRITE =
    MemOperate_RedisOperate_OPERATE_TYPE_T_WRITE;
  static inline bool OPERATE_TYPE_IsValid(int value) {
    return MemOperate_RedisOperate_OPERATE_TYPE_IsValid(value);
  }
  static const OPERATE_TYPE OPERATE_TYPE_MIN =
    MemOperate_RedisOperate_OPERATE_TYPE_OPERATE_TYPE_MIN;
  static const OPERATE_TYPE OPERATE_TYPE_MAX =
    MemOperate_RedisOperate_OPERATE_TYPE_OPERATE_TYPE_MAX;
  static const int OPERATE_TYPE_ARRAYSIZE =
    MemOperate_RedisOperate_OPERATE_TYPE_OPERATE_TYPE_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  OPERATE_TYPE_descriptor() {
    return MemOperate_RedisOperate_OPERATE_TYPE_descriptor();
  }
  static inline const ::std::string& OPERATE_TYPE_Name(OPERATE_TYPE value) {
    return MemOperate_RedisOperate_OPERATE_TYPE_Name(value);
  }
  static inline bool OPERATE_TYPE_Parse(const ::std::string& name,
      OPERATE_TYPE* value) {
    return MemOperate_RedisOperate_OPERATE_TYPE_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // repeated .DataMem.Field fields = 5;
  int fields_size() const;
  void clear_fields();
  static const int kFieldsFieldNumber = 5;
  ::DataMem::Field* mutable_fields(int index);
  ::google::protobuf::RepeatedPtrField< ::DataMem::Field >*
      mutable_fields();
  const ::DataMem::Field& fields(int index) const;
  ::DataMem::Field* add_fields();
  const ::google::protobuf::RepeatedPtrField< ::DataMem::Field >&
      fields() const;

  // optional bytes key_name = 1;
  bool has_key_name() const;
  void clear_key_name();
  static const int kKeyNameFieldNumber = 1;
  const ::std::string& key_name() const;
  void set_key_name(const ::std::string& value);
  #if LANG_CXX11
  void set_key_name(::std::string&& value);
  #endif
  void set_key_name(const char* value);
  void set_key_name(const void* value, size_t size);
  ::std::string* mutable_key_name();
  ::std::string* release_key_name();
  void set_allocated_key_name(::std::string* key_name);

  // optional string redis_cmd_read = 2;
  bool has_redis_cmd_read() const;
  void clear_redis_cmd_read();
  static const int kRedisCmdReadFieldNumber = 2;
  const ::std::string& redis_cmd_read() const;
  void set_redis_cmd_read(const ::std::string& value);
  #if LANG_CXX11
  void set_redis_cmd_read(::std::string&& value);
  #endif
  void set_redis_cmd_read(const char* value);
  void set_redis_cmd_read(const char* value, size_t size);
  ::std::string* mutable_redis_cmd_read();
  ::std::string* release_redis_cmd_read();
  void set_allocated_redis_cmd_read(::std::string* redis_cmd_read);

  // optional string redis_cmd_write = 3;
  bool has_redis_cmd_write() const;
  void clear_redis_cmd_write();
  static const int kRedisCmdWriteFieldNumber = 3;
  const ::std::string& redis_cmd_write() const;
  void set_redis_cmd_write(const ::std::string& value);
  #if LANG_CXX11
  void set_redis_cmd_write(::std::string&& value);
  #endif
  void set_redis_cmd_write(const char* value);
  void set_redis_cmd_write(const char* value, size_t size);
  ::std::string* mutable_redis_cmd_write();
  ::std::string* release_redis_cmd_write();
  void set_allocated_redis_cmd_write(::std::string* redis_cmd_write);

  // optional bytes hash_key = 9;
  bool has_hash_key() const;
  void clear_hash_key();
  static const int kHashKeyFieldNumber = 9;
  const ::std::string& hash_key() const;
  void set_hash_key(const ::std::string& value);
  #if LANG_CXX11
  void set_hash_key(::std::string&& value);
  #endif
  void set_hash_key(const char* value);
  void set_hash_key(const void* value, size_t size);
  ::std::string* mutable_hash_key();
  ::std::string* release_hash_key();
  void set_allocated_hash_key(::std::string* hash_key);

  // optional .DataMem.MemOperate.RedisOperate.OPERATE_TYPE op_type = 4;
  bool has_op_type() const;
  void clear_op_type();
  static const int kOpTypeFieldNumber = 4;
  ::DataMem::MemOperate_RedisOperate_OPERATE_TYPE op_type() const;
  void set_op_type(::DataMem::MemOperate_RedisOperate_OPERATE_TYPE value);

  // optional int32 key_ttl = 6;
  bool has_key_ttl() const;
  void clear_key_ttl();
  static const int kKeyTtlFieldNumber = 6;
  ::google::protobuf::int32 key_ttl() const;
  void set_key_ttl(::google::protobuf::int32 value);

  // optional int32 redis_structure = 7;
  bool has_redis_structure() const;
  void clear_redis_structure();
  static const int kRedisStructureFieldNumber = 7;
  ::google::protobuf::int32 redis_structure() const;
  void set_redis_structure(::google::protobuf::int32 value);

  // optional int32 data_purpose = 8;
  bool has_data_purpose() const;
  void clear_data_purpose();
  static const int kDataPurposeFieldNumber = 8;
  ::google::protobuf::int32 data_purpose() const;
  void set_data_purpose(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:DataMem.MemOperate.RedisOperate)
 private:
  void set_has_key_name();
  void clear_has_key_name();
  void set_has_redis_cmd_read();
  void clear_has_redis_cmd_read();
  void set_has_redis_cmd_write();
  void clear_has_redis_cmd_write();
  void set_has_op_type();
  void clear_has_op_type();
  void set_has_key_ttl();
  void clear_has_key_ttl();
  void set_has_redis_structure();
  void clear_has_redis_structure();
  void set_has_data_purpose();
  void clear_has_data_purpose();
  void set_has_hash_key();
  void clear_has_hash_key();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::DataMem::Field > fields_;
  ::google::protobuf::internal::ArenaStringPtr key_name_;
  ::google::protobuf::internal::ArenaStringPtr redis_cmd_read_;
  ::google::protobuf::internal::ArenaStringPtr redis_cmd_write_;
  ::google::protobuf::internal::ArenaStringPtr hash_key_;
  int op_type_;
  ::google::protobuf::int32 key_ttl_;
  ::google::protobuf::int32 redis_structure_;
  ::google::protobuf::int32 data_purpose_;
  friend struct ::protobuf_dataproxy_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class MemOperate_DbOperate_Condition : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:DataMem.MemOperate.DbOperate.Condition) */ {
 public:
  MemOperate_DbOperate_Condition();
  virtual ~MemOperate_DbOperate_Condition();

  MemOperate_DbOperate_Condition(const MemOperate_DbOperate_Condition& from);

  inline MemOperate_DbOperate_Condition& operator=(const MemOperate_DbOperate_Condition& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MemOperate_DbOperate_Condition(MemOperate_DbOperate_Condition&& from) noexcept
    : MemOperate_DbOperate_Condition() {
    *this = ::std::move(from);
  }

  inline MemOperate_DbOperate_Condition& operator=(MemOperate_DbOperate_Condition&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MemOperate_DbOperate_Condition& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MemOperate_DbOperate_Condition* internal_default_instance() {
    return reinterpret_cast<const MemOperate_DbOperate_Condition*>(
               &_MemOperate_DbOperate_Condition_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(MemOperate_DbOperate_Condition* other);
  friend void swap(MemOperate_DbOperate_Condition& a, MemOperate_DbOperate_Condition& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MemOperate_DbOperate_Condition* New() const final {
    return CreateMaybeMessage<MemOperate_DbOperate_Condition>(NULL);
  }

  MemOperate_DbOperate_Condition* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<MemOperate_DbOperate_Condition>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const MemOperate_DbOperate_Condition& from);
  void MergeFrom(const MemOperate_DbOperate_Condition& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MemOperate_DbOperate_Condition* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef MemOperate_DbOperate_Condition_E_RELATION E_RELATION;
  static const E_RELATION E_RELATION_UNKNOWN =
    MemOperate_DbOperate_Condition_E_RELATION_E_RELATION_UNKNOWN;
  static const E_RELATION EQ =
    MemOperate_DbOperate_Condition_E_RELATION_EQ;
  static const E_RELATION NE =
    MemOperate_DbOperate_Condition_E_RELATION_NE;
  static const E_RELATION GT =
    MemOperate_DbOperate_Condition_E_RELATION_GT;
  static const E_RELATION LT =
    MemOperate_DbOperate_Condition_E_RELATION_LT;
  static const E_RELATION GE =
    MemOperate_DbOperate_Condition_E_RELATION_GE;
  static const E_RELATION LE =
    MemOperate_DbOperate_Condition_E_RELATION_LE;
  static const E_RELATION LIKE =
    MemOperate_DbOperate_Condition_E_RELATION_LIKE;
  static const E_RELATION IN =
    MemOperate_DbOperate_Condition_E_RELATION_IN;
  static inline bool E_RELATION_IsValid(int value) {
    return MemOperate_DbOperate_Condition_E_RELATION_IsValid(value);
  }
  static const E_RELATION E_RELATION_MIN =
    MemOperate_DbOperate_Condition_E_RELATION_E_RELATION_MIN;
  static const E_RELATION E_RELATION_MAX =
    MemOperate_DbOperate_Condition_E_RELATION_E_RELATION_MAX;
  static const int E_RELATION_ARRAYSIZE =
    MemOperate_DbOperate_Condition_E_RELATION_E_RELATION_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  E_RELATION_descriptor() {
    return MemOperate_DbOperate_Condition_E_RELATION_descriptor();
  }
  static inline const ::std::string& E_RELATION_Name(E_RELATION value) {
    return MemOperate_DbOperate_Condition_E_RELATION_Name(value);
  }
  static inline bool E_RELATION_Parse(const ::std::string& name,
      E_RELATION* value) {
    return MemOperate_DbOperate_Condition_E_RELATION_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // repeated bytes col_values = 4;
  int col_values_size() const;
  void clear_col_values();
  static const int kColValuesFieldNumber = 4;
  const ::std::string& col_values(int index) const;
  ::std::string* mutable_col_values(int index);
  void set_col_values(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_col_values(int index, ::std::string&& value);
  #endif
  void set_col_values(int index, const char* value);
  void set_col_values(int index, const void* value, size_t size);
  ::std::string* add_col_values();
  void add_col_values(const ::std::string& value);
  #if LANG_CXX11
  void add_col_values(::std::string&& value);
  #endif
  void add_col_values(const char* value);
  void add_col_values(const void* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& col_values() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_col_values();

  // optional string col_name = 3;
  bool has_col_name() const;
  void clear_col_name();
  static const int kColNameFieldNumber = 3;
  const ::std::string& col_name() const;
  void set_col_name(const ::std::string& value);
  #if LANG_CXX11
  void set_col_name(::std::string&& value);
  #endif
  void set_col_name(const char* value);
  void set_col_name(const char* value, size_t size);
  ::std::string* mutable_col_name();
  ::std::string* release_col_name();
  void set_allocated_col_name(::std::string* col_name);

  // optional string col_name_right = 5;
  bool has_col_name_right() const;
  void clear_col_name_right();
  static const int kColNameRightFieldNumber = 5;
  const ::std::string& col_name_right() const;
  void set_col_name_right(const ::std::string& value);
  #if LANG_CXX11
  void set_col_name_right(::std::string&& value);
  #endif
  void set_col_name_right(const char* value);
  void set_col_name_right(const char* value, size_t size);
  ::std::string* mutable_col_name_right();
  ::std::string* release_col_name_right();
  void set_allocated_col_name_right(::std::string* col_name_right);

  // optional .DataMem.MemOperate.DbOperate.Condition.E_RELATION relation = 1;
  bool has_relation() const;
  void clear_relation();
  static const int kRelationFieldNumber = 1;
  ::DataMem::MemOperate_DbOperate_Condition_E_RELATION relation() const;
  void set_relation(::DataMem::MemOperate_DbOperate_Condition_E_RELATION value);

  // optional .DataMem.E_COL_TYPE col_type = 2;
  bool has_col_type() const;
  void clear_col_type();
  static const int kColTypeFieldNumber = 2;
  ::DataMem::E_COL_TYPE col_type() const;
  void set_col_type(::DataMem::E_COL_TYPE value);

  // @@protoc_insertion_point(class_scope:DataMem.MemOperate.DbOperate.Condition)
 private:
  void set_has_relation();
  void clear_has_relation();
  void set_has_col_type();
  void clear_has_col_type();
  void set_has_col_name();
  void clear_has_col_name();
  void set_has_col_name_right();
  void clear_has_col_name_right();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::std::string> col_values_;
  ::google::protobuf::internal::ArenaStringPtr col_name_;
  ::google::protobuf::internal::ArenaStringPtr col_name_right_;
  int relation_;
  int col_type_;
  friend struct ::protobuf_dataproxy_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class MemOperate_DbOperate_ConditionGroup : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:DataMem.MemOperate.DbOperate.ConditionGroup) */ {
 public:
  MemOperate_DbOperate_ConditionGroup();
  virtual ~MemOperate_DbOperate_ConditionGroup();

  MemOperate_DbOperate_ConditionGroup(const MemOperate_DbOperate_ConditionGroup& from);

  inline MemOperate_DbOperate_ConditionGroup& operator=(const MemOperate_DbOperate_ConditionGroup& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MemOperate_DbOperate_ConditionGroup(MemOperate_DbOperate_ConditionGroup&& from) noexcept
    : MemOperate_DbOperate_ConditionGroup() {
    *this = ::std::move(from);
  }

  inline MemOperate_DbOperate_ConditionGroup& operator=(MemOperate_DbOperate_ConditionGroup&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MemOperate_DbOperate_ConditionGroup& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MemOperate_DbOperate_ConditionGroup* internal_default_instance() {
    return reinterpret_cast<const MemOperate_DbOperate_ConditionGroup*>(
               &_MemOperate_DbOperate_ConditionGroup_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void Swap(MemOperate_DbOperate_ConditionGroup* other);
  friend void swap(MemOperate_DbOperate_ConditionGroup& a, MemOperate_DbOperate_ConditionGroup& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MemOperate_DbOperate_ConditionGroup* New() const final {
    return CreateMaybeMessage<MemOperate_DbOperate_ConditionGroup>(NULL);
  }

  MemOperate_DbOperate_ConditionGroup* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<MemOperate_DbOperate_ConditionGroup>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const MemOperate_DbOperate_ConditionGroup& from);
  void MergeFrom(const MemOperate_DbOperate_ConditionGroup& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MemOperate_DbOperate_ConditionGroup* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef MemOperate_DbOperate_ConditionGroup_E_RELATION E_RELATION;
  static const E_RELATION E_RELATION_UNKNOWN =
    MemOperate_DbOperate_ConditionGroup_E_RELATION_E_RELATION_UNKNOWN;
  static const E_RELATION AND =
    MemOperate_DbOperate_ConditionGroup_E_RELATION_AND;
  static const E_RELATION OR =
    MemOperate_DbOperate_ConditionGroup_E_RELATION_OR;
  static inline bool E_RELATION_IsValid(int value) {
    return MemOperate_DbOperate_ConditionGroup_E_RELATION_IsValid(value);
  }
  static const E_RELATION E_RELATION_MIN =
    MemOperate_DbOperate_ConditionGroup_E_RELATION_E_RELATION_MIN;
  static const E_RELATION E_RELATION_MAX =
    MemOperate_DbOperate_ConditionGroup_E_RELATION_E_RELATION_MAX;
  static const int E_RELATION_ARRAYSIZE =
    MemOperate_DbOperate_ConditionGroup_E_RELATION_E_RELATION_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  E_RELATION_descriptor() {
    return MemOperate_DbOperate_ConditionGroup_E_RELATION_descriptor();
  }
  static inline const ::std::string& E_RELATION_Name(E_RELATION value) {
    return MemOperate_DbOperate_ConditionGroup_E_RELATION_Name(value);
  }
  static inline bool E_RELATION_Parse(const ::std::string& name,
      E_RELATION* value) {
    return MemOperate_DbOperate_ConditionGroup_E_RELATION_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // repeated .DataMem.MemOperate.DbOperate.Condition condition = 2;
  int condition_size() const;
  void clear_condition();
  static const int kConditionFieldNumber = 2;
  ::DataMem::MemOperate_DbOperate_Condition* mutable_condition(int index);
  ::google::protobuf::RepeatedPtrField< ::DataMem::MemOperate_DbOperate_Condition >*
      mutable_condition();
  const ::DataMem::MemOperate_DbOperate_Condition& condition(int index) const;
  ::DataMem::MemOperate_DbOperate_Condition* add_condition();
  const ::google::protobuf::RepeatedPtrField< ::DataMem::MemOperate_DbOperate_Condition >&
      condition() const;

  // optional .DataMem.MemOperate.DbOperate.ConditionGroup.E_RELATION relation = 1;
  bool has_relation() const;
  void clear_relation();
  static const int kRelationFieldNumber = 1;
  ::DataMem::MemOperate_DbOperate_ConditionGroup_E_RELATION relation() const;
  void set_relation(::DataMem::MemOperate_DbOperate_ConditionGroup_E_RELATION value);

  // @@protoc_insertion_point(class_scope:DataMem.MemOperate.DbOperate.ConditionGroup)
 private:
  void set_has_relation();
  void clear_has_relation();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::DataMem::MemOperate_DbOperate_Condition > condition_;
  int relation_;
  friend struct ::protobuf_dataproxy_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class MemOperate_DbOperate_OrderBy : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:DataMem.MemOperate.DbOperate.OrderBy) */ {
 public:
  MemOperate_DbOperate_OrderBy();
  virtual ~MemOperate_DbOperate_OrderBy();

  MemOperate_DbOperate_OrderBy(const MemOperate_DbOperate_OrderBy& from);

  inline MemOperate_DbOperate_OrderBy& operator=(const MemOperate_DbOperate_OrderBy& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MemOperate_DbOperate_OrderBy(MemOperate_DbOperate_OrderBy&& from) noexcept
    : MemOperate_DbOperate_OrderBy() {
    *this = ::std::move(from);
  }

  inline MemOperate_DbOperate_OrderBy& operator=(MemOperate_DbOperate_OrderBy&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MemOperate_DbOperate_OrderBy& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MemOperate_DbOperate_OrderBy* internal_default_instance() {
    return reinterpret_cast<const MemOperate_DbOperate_OrderBy*>(
               &_MemOperate_DbOperate_OrderBy_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void Swap(MemOperate_DbOperate_OrderBy* other);
  friend void swap(MemOperate_DbOperate_OrderBy& a, MemOperate_DbOperate_OrderBy& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MemOperate_DbOperate_OrderBy* New() const final {
    return CreateMaybeMessage<MemOperate_DbOperate_OrderBy>(NULL);
  }

  MemOperate_DbOperate_OrderBy* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<MemOperate_DbOperate_OrderBy>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const MemOperate_DbOperate_OrderBy& from);
  void MergeFrom(const MemOperate_DbOperate_OrderBy& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MemOperate_DbOperate_OrderBy* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef MemOperate_DbOperate_OrderBy_E_RELATION E_RELATION;
  static const E_RELATION E_RELATION_UNKNOWN =
    MemOperate_DbOperate_OrderBy_E_RELATION_E_RELATION_UNKNOWN;
  static const E_RELATION ASC =
    MemOperate_DbOperate_OrderBy_E_RELATION_ASC;
  static const E_RELATION DESC =
    MemOperate_DbOperate_OrderBy_E_RELATION_DESC;
  static inline bool E_RELATION_IsValid(int value) {
    return MemOperate_DbOperate_OrderBy_E_RELATION_IsValid(value);
  }
  static const E_RELATION E_RELATION_MIN =
    MemOperate_DbOperate_OrderBy_E_RELATION_E_RELATION_MIN;
  static const E_RELATION E_RELATION_MAX =
    MemOperate_DbOperate_OrderBy_E_RELATION_E_RELATION_MAX;
  static const int E_RELATION_ARRAYSIZE =
    MemOperate_DbOperate_OrderBy_E_RELATION_E_RELATION_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  E_RELATION_descriptor() {
    return MemOperate_DbOperate_OrderBy_E_RELATION_descriptor();
  }
  static inline const ::std::string& E_RELATION_Name(E_RELATION value) {
    return MemOperate_DbOperate_OrderBy_E_RELATION_Name(value);
  }
  static inline bool E_RELATION_Parse(const ::std::string& name,
      E_RELATION* value) {
    return MemOperate_DbOperate_OrderBy_E_RELATION_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional string col_name = 2;
  bool has_col_name() const;
  void clear_col_name();
  static const int kColNameFieldNumber = 2;
  const ::std::string& col_name() const;
  void set_col_name(const ::std::string& value);
  #if LANG_CXX11
  void set_col_name(::std::string&& value);
  #endif
  void set_col_name(const char* value);
  void set_col_name(const char* value, size_t size);
  ::std::string* mutable_col_name();
  ::std::string* release_col_name();
  void set_allocated_col_name(::std::string* col_name);

  // optional .DataMem.MemOperate.DbOperate.OrderBy.E_RELATION relation = 1;
  bool has_relation() const;
  void clear_relation();
  static const int kRelationFieldNumber = 1;
  ::DataMem::MemOperate_DbOperate_OrderBy_E_RELATION relation() const;
  void set_relation(::DataMem::MemOperate_DbOperate_OrderBy_E_RELATION value);

  // @@protoc_insertion_point(class_scope:DataMem.MemOperate.DbOperate.OrderBy)
 private:
  void set_has_relation();
  void clear_has_relation();
  void set_has_col_name();
  void clear_has_col_name();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr col_name_;
  int relation_;
  friend struct ::protobuf_dataproxy_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class MemOperate_DbOperate : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:DataMem.MemOperate.DbOperate) */ {
 public:
  MemOperate_DbOperate();
  virtual ~MemOperate_DbOperate();

  MemOperate_DbOperate(const MemOperate_DbOperate& from);

  inline MemOperate_DbOperate& operator=(const MemOperate_DbOperate& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MemOperate_DbOperate(MemOperate_DbOperate&& from) noexcept
    : MemOperate_DbOperate() {
    *this = ::std::move(from);
  }

  inline MemOperate_DbOperate& operator=(MemOperate_DbOperate&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MemOperate_DbOperate& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MemOperate_DbOperate* internal_default_instance() {
    return reinterpret_cast<const MemOperate_DbOperate*>(
               &_MemOperate_DbOperate_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  void Swap(MemOperate_DbOperate* other);
  friend void swap(MemOperate_DbOperate& a, MemOperate_DbOperate& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MemOperate_DbOperate* New() const final {
    return CreateMaybeMessage<MemOperate_DbOperate>(NULL);
  }

  MemOperate_DbOperate* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<MemOperate_DbOperate>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const MemOperate_DbOperate& from);
  void MergeFrom(const MemOperate_DbOperate& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MemOperate_DbOperate* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef MemOperate_DbOperate_Condition Condition;
  typedef MemOperate_DbOperate_ConditionGroup ConditionGroup;
  typedef MemOperate_DbOperate_OrderBy OrderBy;

  typedef MemOperate_DbOperate_E_QUERY_TYPE E_QUERY_TYPE;
  static const E_QUERY_TYPE E_QUERY_TYPE_UNKNONW =
    MemOperate_DbOperate_E_QUERY_TYPE_E_QUERY_TYPE_UNKNONW;
  static const E_QUERY_TYPE SELECT =
    MemOperate_DbOperate_E_QUERY_TYPE_SELECT;
  static const E_QUERY_TYPE INSERT =
    MemOperate_DbOperate_E_QUERY_TYPE_INSERT;
  static const E_QUERY_TYPE INSERT_IGNORE =
    MemOperate_DbOperate_E_QUERY_TYPE_INSERT_IGNORE;
  static const E_QUERY_TYPE UPDATE =
    MemOperate_DbOperate_E_QUERY_TYPE_UPDATE;
  static const E_QUERY_TYPE REPLACE =
    MemOperate_DbOperate_E_QUERY_TYPE_REPLACE;
  static const E_QUERY_TYPE DELETE =
    MemOperate_DbOperate_E_QUERY_TYPE_DELETE;
  static const E_QUERY_TYPE CUSTOM =
    MemOperate_DbOperate_E_QUERY_TYPE_CUSTOM;
  static const E_QUERY_TYPE BULK =
    MemOperate_DbOperate_E_QUERY_TYPE_BULK;
  static inline bool E_QUERY_TYPE_IsValid(int value) {
    return MemOperate_DbOperate_E_QUERY_TYPE_IsValid(value);
  }
  static const E_QUERY_TYPE E_QUERY_TYPE_MIN =
    MemOperate_DbOperate_E_QUERY_TYPE_E_QUERY_TYPE_MIN;
  static const E_QUERY_TYPE E_QUERY_TYPE_MAX =
    MemOperate_DbOperate_E_QUERY_TYPE_E_QUERY_TYPE_MAX;
  static const int E_QUERY_TYPE_ARRAYSIZE =
    MemOperate_DbOperate_E_QUERY_TYPE_E_QUERY_TYPE_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  E_QUERY_TYPE_descriptor() {
    return MemOperate_DbOperate_E_QUERY_TYPE_descriptor();
  }
  static inline const ::std::string& E_QUERY_TYPE_Name(E_QUERY_TYPE value) {
    return MemOperate_DbOperate_E_QUERY_TYPE_Name(value);
  }
  static inline bool E_QUERY_TYPE_Parse(const ::std::string& name,
      E_QUERY_TYPE* value) {
    return MemOperate_DbOperate_E_QUERY_TYPE_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // repeated .DataMem.Field fields = 3;
  int fields_size() const;
  void clear_fields();
  static const int kFieldsFieldNumber = 3;
  ::DataMem::Field* mutable_fields(int index);
  ::google::protobuf::RepeatedPtrField< ::DataMem::Field >*
      mutable_fields();
  const ::DataMem::Field& fields(int index) const;
  ::DataMem::Field* add_fields();
  const ::google::protobuf::RepeatedPtrField< ::DataMem::Field >&
      fields() const;

  // repeated .DataMem.MemOperate.DbOperate.ConditionGroup conditions = 4;
  int conditions_size() const;
  void clear_conditions();
  static const int kConditionsFieldNumber = 4;
  ::DataMem::MemOperate_DbOperate_ConditionGroup* mutable_conditions(int index);
  ::google::protobuf::RepeatedPtrField< ::DataMem::MemOperate_DbOperate_ConditionGroup >*
      mutable_conditions();
  const ::DataMem::MemOperate_DbOperate_ConditionGroup& conditions(int index) const;
  ::DataMem::MemOperate_DbOperate_ConditionGroup* add_conditions();
  const ::google::protobuf::RepeatedPtrField< ::DataMem::MemOperate_DbOperate_ConditionGroup >&
      conditions() const;

  // repeated string groupby_col = 5;
  int groupby_col_size() const;
  void clear_groupby_col();
  static const int kGroupbyColFieldNumber = 5;
  const ::std::string& groupby_col(int index) const;
  ::std::string* mutable_groupby_col(int index);
  void set_groupby_col(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_groupby_col(int index, ::std::string&& value);
  #endif
  void set_groupby_col(int index, const char* value);
  void set_groupby_col(int index, const char* value, size_t size);
  ::std::string* add_groupby_col();
  void add_groupby_col(const ::std::string& value);
  #if LANG_CXX11
  void add_groupby_col(::std::string&& value);
  #endif
  void add_groupby_col(const char* value);
  void add_groupby_col(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& groupby_col() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_groupby_col();

  // repeated .DataMem.MemOperate.DbOperate.OrderBy orderby_col = 6;
  int orderby_col_size() const;
  void clear_orderby_col();
  static const int kOrderbyColFieldNumber = 6;
  ::DataMem::MemOperate_DbOperate_OrderBy* mutable_orderby_col(int index);
  ::google::protobuf::RepeatedPtrField< ::DataMem::MemOperate_DbOperate_OrderBy >*
      mutable_orderby_col();
  const ::DataMem::MemOperate_DbOperate_OrderBy& orderby_col(int index) const;
  ::DataMem::MemOperate_DbOperate_OrderBy* add_orderby_col();
  const ::google::protobuf::RepeatedPtrField< ::DataMem::MemOperate_DbOperate_OrderBy >&
      orderby_col() const;

  // optional string table_name = 2;
  bool has_table_name() const;
  void clear_table_name();
  static const int kTableNameFieldNumber = 2;
  const ::std::string& table_name() const;
  void set_table_name(const ::std::string& value);
  #if LANG_CXX11
  void set_table_name(::std::string&& value);
  #endif
  void set_table_name(const char* value);
  void set_table_name(const char* value, size_t size);
  ::std::string* mutable_table_name();
  ::std::string* release_table_name();
  void set_allocated_table_name(::std::string* table_name);

  // optional .DataMem.MemOperate.DbOperate.E_QUERY_TYPE query_type = 1;
  bool has_query_type() const;
  void clear_query_type();
  static const int kQueryTypeFieldNumber = 1;
  ::DataMem::MemOperate_DbOperate_E_QUERY_TYPE query_type() const;
  void set_query_type(::DataMem::MemOperate_DbOperate_E_QUERY_TYPE value);

  // optional .DataMem.MemOperate.DbOperate.ConditionGroup.E_RELATION group_relation = 7;
  bool has_group_relation() const;
  void clear_group_relation();
  static const int kGroupRelationFieldNumber = 7;
  ::DataMem::MemOperate_DbOperate_ConditionGroup_E_RELATION group_relation() const;
  void set_group_relation(::DataMem::MemOperate_DbOperate_ConditionGroup_E_RELATION value);

  // optional uint32 limit = 8;
  bool has_limit() const;
  void clear_limit();
  static const int kLimitFieldNumber = 8;
  ::google::protobuf::uint32 limit() const;
  void set_limit(::google::protobuf::uint32 value);

  // optional uint32 limit_from = 9;
  bool has_limit_from() const;
  void clear_limit_from();
  static const int kLimitFromFieldNumber = 9;
  ::google::protobuf::uint32 limit_from() const;
  void set_limit_from(::google::protobuf::uint32 value);

  // optional uint64 mod_factor = 10;
  bool has_mod_factor() const;
  void clear_mod_factor();
  static const int kModFactorFieldNumber = 10;
  ::google::protobuf::uint64 mod_factor() const;
  void set_mod_factor(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:DataMem.MemOperate.DbOperate)
 private:
  void set_has_query_type();
  void clear_has_query_type();
  void set_has_table_name();
  void clear_has_table_name();
  void set_has_group_relation();
  void clear_has_group_relation();
  void set_has_limit();
  void clear_has_limit();
  void set_has_limit_from();
  void clear_has_limit_from();
  void set_has_mod_factor();
  void clear_has_mod_factor();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::DataMem::Field > fields_;
  ::google::protobuf::RepeatedPtrField< ::DataMem::MemOperate_DbOperate_ConditionGroup > conditions_;
  ::google::protobuf::RepeatedPtrField< ::std::string> groupby_col_;
  ::google::protobuf::RepeatedPtrField< ::DataMem::MemOperate_DbOperate_OrderBy > orderby_col_;
  ::google::protobuf::internal::ArenaStringPtr table_name_;
  int query_type_;
  int group_relation_;
  ::google::protobuf::uint32 limit_;
  ::google::protobuf::uint32 limit_from_;
  ::google::protobuf::uint64 mod_factor_;
  friend struct ::protobuf_dataproxy_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class MemOperate : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:DataMem.MemOperate) */ {
 public:
  MemOperate();
  virtual ~MemOperate();

  MemOperate(const MemOperate& from);

  inline MemOperate& operator=(const MemOperate& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MemOperate(MemOperate&& from) noexcept
    : MemOperate() {
    *this = ::std::move(from);
  }

  inline MemOperate& operator=(MemOperate&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MemOperate& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MemOperate* internal_default_instance() {
    return reinterpret_cast<const MemOperate*>(
               &_MemOperate_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  void Swap(MemOperate* other);
  friend void swap(MemOperate& a, MemOperate& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MemOperate* New() const final {
    return CreateMaybeMessage<MemOperate>(NULL);
  }

  MemOperate* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<MemOperate>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const MemOperate& from);
  void MergeFrom(const MemOperate& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MemOperate* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef MemOperate_RedisOperate RedisOperate;
  typedef MemOperate_DbOperate DbOperate;

  // accessors -------------------------------------------------------

  // optional .DataMem.MemOperate.RedisOperate redis_operate = 2;
  bool has_redis_operate() const;
  void clear_redis_operate();
  static const int kRedisOperateFieldNumber = 2;
  private:
  const ::DataMem::MemOperate_RedisOperate& _internal_redis_operate() const;
  public:
  const ::DataMem::MemOperate_RedisOperate& redis_operate() const;
  ::DataMem::MemOperate_RedisOperate* release_redis_operate();
  ::DataMem::MemOperate_RedisOperate* mutable_redis_operate();
  void set_allocated_redis_operate(::DataMem::MemOperate_RedisOperate* redis_operate);

  // optional .DataMem.MemOperate.DbOperate db_operate = 3;
  bool has_db_operate() const;
  void clear_db_operate();
  static const int kDbOperateFieldNumber = 3;
  private:
  const ::DataMem::MemOperate_DbOperate& _internal_db_operate() const;
  public:
  const ::DataMem::MemOperate_DbOperate& db_operate() const;
  ::DataMem::MemOperate_DbOperate* release_db_operate();
  ::DataMem::MemOperate_DbOperate* mutable_db_operate();
  void set_allocated_db_operate(::DataMem::MemOperate_DbOperate* db_operate);

  // optional uint64 section_factor = 1;
  bool has_section_factor() const;
  void clear_section_factor();
  static const int kSectionFactorFieldNumber = 1;
  ::google::protobuf::uint64 section_factor() const;
  void set_section_factor(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:DataMem.MemOperate)
 private:
  void set_has_section_factor();
  void clear_has_section_factor();
  void set_has_redis_operate();
  void clear_has_redis_operate();
  void set_has_db_operate();
  void clear_has_db_operate();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::DataMem::MemOperate_RedisOperate* redis_operate_;
  ::DataMem::MemOperate_DbOperate* db_operate_;
  ::google::protobuf::uint64 section_factor_;
  friend struct ::protobuf_dataproxy_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Record : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:DataMem.Record) */ {
 public:
  Record();
  virtual ~Record();

  Record(const Record& from);

  inline Record& operator=(const Record& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Record(Record&& from) noexcept
    : Record() {
    *this = ::std::move(from);
  }

  inline Record& operator=(Record&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Record& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Record* internal_default_instance() {
    return reinterpret_cast<const Record*>(
               &_Record_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  void Swap(Record* other);
  friend void swap(Record& a, Record& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Record* New() const final {
    return CreateMaybeMessage<Record>(NULL);
  }

  Record* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Record>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Record& from);
  void MergeFrom(const Record& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Record* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .DataMem.Field field_info = 1;
  int field_info_size() const;
  void clear_field_info();
  static const int kFieldInfoFieldNumber = 1;
  ::DataMem::Field* mutable_field_info(int index);
  ::google::protobuf::RepeatedPtrField< ::DataMem::Field >*
      mutable_field_info();
  const ::DataMem::Field& field_info(int index) const;
  ::DataMem::Field* add_field_info();
  const ::google::protobuf::RepeatedPtrField< ::DataMem::Field >&
      field_info() const;

  // @@protoc_insertion_point(class_scope:DataMem.Record)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::DataMem::Field > field_info_;
  friend struct ::protobuf_dataproxy_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Field : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:DataMem.Field) */ {
 public:
  Field();
  virtual ~Field();

  Field(const Field& from);

  inline Field& operator=(const Field& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Field(Field&& from) noexcept
    : Field() {
    *this = ::std::move(from);
  }

  inline Field& operator=(Field&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Field& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Field* internal_default_instance() {
    return reinterpret_cast<const Field*>(
               &_Field_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  void Swap(Field* other);
  friend void swap(Field& a, Field& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Field* New() const final {
    return CreateMaybeMessage<Field>(NULL);
  }

  Field* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Field>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Field& from);
  void MergeFrom(const Field& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Field* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string col_name = 1;
  bool has_col_name() const;
  void clear_col_name();
  static const int kColNameFieldNumber = 1;
  const ::std::string& col_name() const;
  void set_col_name(const ::std::string& value);
  #if LANG_CXX11
  void set_col_name(::std::string&& value);
  #endif
  void set_col_name(const char* value);
  void set_col_name(const char* value, size_t size);
  ::std::string* mutable_col_name();
  ::std::string* release_col_name();
  void set_allocated_col_name(::std::string* col_name);

  // optional bytes col_value = 3;
  bool has_col_value() const;
  void clear_col_value();
  static const int kColValueFieldNumber = 3;
  const ::std::string& col_value() const;
  void set_col_value(const ::std::string& value);
  #if LANG_CXX11
  void set_col_value(::std::string&& value);
  #endif
  void set_col_value(const char* value);
  void set_col_value(const void* value, size_t size);
  ::std::string* mutable_col_value();
  ::std::string* release_col_value();
  void set_allocated_col_value(::std::string* col_value);

  // optional string col_as = 4;
  bool has_col_as() const;
  void clear_col_as();
  static const int kColAsFieldNumber = 4;
  const ::std::string& col_as() const;
  void set_col_as(const ::std::string& value);
  #if LANG_CXX11
  void set_col_as(::std::string&& value);
  #endif
  void set_col_as(const char* value);
  void set_col_as(const char* value, size_t size);
  ::std::string* mutable_col_as();
  ::std::string* release_col_as();
  void set_allocated_col_as(::std::string* col_as);

  // optional .DataMem.E_COL_TYPE col_type = 2;
  bool has_col_type() const;
  void clear_col_type();
  static const int kColTypeFieldNumber = 2;
  ::DataMem::E_COL_TYPE col_type() const;
  void set_col_type(::DataMem::E_COL_TYPE value);

  // @@protoc_insertion_point(class_scope:DataMem.Field)
 private:
  void set_has_col_name();
  void clear_has_col_name();
  void set_has_col_type();
  void clear_has_col_type();
  void set_has_col_value();
  void clear_has_col_value();
  void set_has_col_as();
  void clear_has_col_as();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr col_name_;
  ::google::protobuf::internal::ArenaStringPtr col_value_;
  ::google::protobuf::internal::ArenaStringPtr col_as_;
  int col_type_;
  friend struct ::protobuf_dataproxy_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class MemRsp_DataLocate : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:DataMem.MemRsp.DataLocate) */ {
 public:
  MemRsp_DataLocate();
  virtual ~MemRsp_DataLocate();

  MemRsp_DataLocate(const MemRsp_DataLocate& from);

  inline MemRsp_DataLocate& operator=(const MemRsp_DataLocate& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MemRsp_DataLocate(MemRsp_DataLocate&& from) noexcept
    : MemRsp_DataLocate() {
    *this = ::std::move(from);
  }

  inline MemRsp_DataLocate& operator=(MemRsp_DataLocate&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MemRsp_DataLocate& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MemRsp_DataLocate* internal_default_instance() {
    return reinterpret_cast<const MemRsp_DataLocate*>(
               &_MemRsp_DataLocate_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  void Swap(MemRsp_DataLocate* other);
  friend void swap(MemRsp_DataLocate& a, MemRsp_DataLocate& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MemRsp_DataLocate* New() const final {
    return CreateMaybeMessage<MemRsp_DataLocate>(NULL);
  }

  MemRsp_DataLocate* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<MemRsp_DataLocate>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const MemRsp_DataLocate& from);
  void MergeFrom(const MemRsp_DataLocate& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MemRsp_DataLocate* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 section_from = 1;
  bool has_section_from() const;
  void clear_section_from();
  static const int kSectionFromFieldNumber = 1;
  ::google::protobuf::uint32 section_from() const;
  void set_section_from(::google::protobuf::uint32 value);

  // optional uint32 section_to = 2;
  bool has_section_to() const;
  void clear_section_to();
  static const int kSectionToFieldNumber = 2;
  ::google::protobuf::uint32 section_to() const;
  void set_section_to(::google::protobuf::uint32 value);

  // optional uint32 hash = 3;
  bool has_hash() const;
  void clear_hash();
  static const int kHashFieldNumber = 3;
  ::google::protobuf::uint32 hash() const;
  void set_hash(::google::protobuf::uint32 value);

  // optional uint32 divisor = 4;
  bool has_divisor() const;
  void clear_divisor();
  static const int kDivisorFieldNumber = 4;
  ::google::protobuf::uint32 divisor() const;
  void set_divisor(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:DataMem.MemRsp.DataLocate)
 private:
  void set_has_section_from();
  void clear_has_section_from();
  void set_has_section_to();
  void clear_has_section_to();
  void set_has_hash();
  void clear_has_hash();
  void set_has_divisor();
  void clear_has_divisor();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 section_from_;
  ::google::protobuf::uint32 section_to_;
  ::google::protobuf::uint32 hash_;
  ::google::protobuf::uint32 divisor_;
  friend struct ::protobuf_dataproxy_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class MemRsp : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:DataMem.MemRsp) */ {
 public:
  MemRsp();
  virtual ~MemRsp();

  MemRsp(const MemRsp& from);

  inline MemRsp& operator=(const MemRsp& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MemRsp(MemRsp&& from) noexcept
    : MemRsp() {
    *this = ::std::move(from);
  }

  inline MemRsp& operator=(MemRsp&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MemRsp& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MemRsp* internal_default_instance() {
    return reinterpret_cast<const MemRsp*>(
               &_MemRsp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  void Swap(MemRsp* other);
  friend void swap(MemRsp& a, MemRsp& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MemRsp* New() const final {
    return CreateMaybeMessage<MemRsp>(NULL);
  }

  MemRsp* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<MemRsp>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const MemRsp& from);
  void MergeFrom(const MemRsp& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MemRsp* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef MemRsp_DataLocate DataLocate;

  typedef MemRsp_E_RESULT_FROM E_RESULT_FROM;
  static const E_RESULT_FROM E_RESULT_FROM_UNKNOWN =
    MemRsp_E_RESULT_FROM_E_RESULT_FROM_UNKNOWN;
  static const E_RESULT_FROM FROM_REDIS =
    MemRsp_E_RESULT_FROM_FROM_REDIS;
  static const E_RESULT_FROM FROM_DB =
    MemRsp_E_RESULT_FROM_FROM_DB;
  static inline bool E_RESULT_FROM_IsValid(int value) {
    return MemRsp_E_RESULT_FROM_IsValid(value);
  }
  static const E_RESULT_FROM E_RESULT_FROM_MIN =
    MemRsp_E_RESULT_FROM_E_RESULT_FROM_MIN;
  static const E_RESULT_FROM E_RESULT_FROM_MAX =
    MemRsp_E_RESULT_FROM_E_RESULT_FROM_MAX;
  static const int E_RESULT_FROM_ARRAYSIZE =
    MemRsp_E_RESULT_FROM_E_RESULT_FROM_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  E_RESULT_FROM_descriptor() {
    return MemRsp_E_RESULT_FROM_descriptor();
  }
  static inline const ::std::string& E_RESULT_FROM_Name(E_RESULT_FROM value) {
    return MemRsp_E_RESULT_FROM_Name(value);
  }
  static inline bool E_RESULT_FROM_Parse(const ::std::string& name,
      E_RESULT_FROM* value) {
    return MemRsp_E_RESULT_FROM_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // repeated .DataMem.Record record_data = 5;
  int record_data_size() const;
  void clear_record_data();
  static const int kRecordDataFieldNumber = 5;
  ::DataMem::Record* mutable_record_data(int index);
  ::google::protobuf::RepeatedPtrField< ::DataMem::Record >*
      mutable_record_data();
  const ::DataMem::Record& record_data(int index) const;
  ::DataMem::Record* add_record_data();
  const ::google::protobuf::RepeatedPtrField< ::DataMem::Record >&
      record_data() const;

  // optional bytes err_msg = 2;
  bool has_err_msg() const;
  void clear_err_msg();
  static const int kErrMsgFieldNumber = 2;
  const ::std::string& err_msg() const;
  void set_err_msg(const ::std::string& value);
  #if LANG_CXX11
  void set_err_msg(::std::string&& value);
  #endif
  void set_err_msg(const char* value);
  void set_err_msg(const void* value, size_t size);
  ::std::string* mutable_err_msg();
  ::std::string* release_err_msg();
  void set_allocated_err_msg(::std::string* err_msg);

  // optional .DataMem.MemRsp.DataLocate locate = 7;
  bool has_locate() const;
  void clear_locate();
  static const int kLocateFieldNumber = 7;
  private:
  const ::DataMem::MemRsp_DataLocate& _internal_locate() const;
  public:
  const ::DataMem::MemRsp_DataLocate& locate() const;
  ::DataMem::MemRsp_DataLocate* release_locate();
  ::DataMem::MemRsp_DataLocate* mutable_locate();
  void set_allocated_locate(::DataMem::MemRsp_DataLocate* locate);

  // optional int32 err_no = 1;
  bool has_err_no() const;
  void clear_err_no();
  static const int kErrNoFieldNumber = 1;
  ::google::protobuf::int32 err_no() const;
  void set_err_no(::google::protobuf::int32 value);

  // optional int32 totalcount = 3;
  bool has_totalcount() const;
  void clear_totalcount();
  static const int kTotalcountFieldNumber = 3;
  ::google::protobuf::int32 totalcount() const;
  void set_totalcount(::google::protobuf::int32 value);

  // optional int32 curcount = 4;
  bool has_curcount() const;
  void clear_curcount();
  static const int kCurcountFieldNumber = 4;
  ::google::protobuf::int32 curcount() const;
  void set_curcount(::google::protobuf::int32 value);

  // optional int32 from = 6;
  bool has_from() const;
  void clear_from();
  static const int kFromFieldNumber = 6;
  ::google::protobuf::int32 from() const;
  void set_from(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:DataMem.MemRsp)
 private:
  void set_has_err_no();
  void clear_has_err_no();
  void set_has_err_msg();
  void clear_has_err_msg();
  void set_has_totalcount();
  void clear_has_totalcount();
  void set_has_curcount();
  void clear_has_curcount();
  void set_has_from();
  void clear_has_from();
  void set_has_locate();
  void clear_has_locate();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::DataMem::Record > record_data_;
  ::google::protobuf::internal::ArenaStringPtr err_msg_;
  ::DataMem::MemRsp_DataLocate* locate_;
  ::google::protobuf::int32 err_no_;
  ::google::protobuf::int32 totalcount_;
  ::google::protobuf::int32 curcount_;
  ::google::protobuf::int32 from_;
  friend struct ::protobuf_dataproxy_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// MemOperate_RedisOperate

// optional bytes key_name = 1;
inline bool MemOperate_RedisOperate::has_key_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MemOperate_RedisOperate::set_has_key_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MemOperate_RedisOperate::clear_has_key_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MemOperate_RedisOperate::clear_key_name() {
  key_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_key_name();
}
inline const ::std::string& MemOperate_RedisOperate::key_name() const {
  // @@protoc_insertion_point(field_get:DataMem.MemOperate.RedisOperate.key_name)
  return key_name_.GetNoArena();
}
inline void MemOperate_RedisOperate::set_key_name(const ::std::string& value) {
  set_has_key_name();
  key_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:DataMem.MemOperate.RedisOperate.key_name)
}
#if LANG_CXX11
inline void MemOperate_RedisOperate::set_key_name(::std::string&& value) {
  set_has_key_name();
  key_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:DataMem.MemOperate.RedisOperate.key_name)
}
#endif
inline void MemOperate_RedisOperate::set_key_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_key_name();
  key_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:DataMem.MemOperate.RedisOperate.key_name)
}
inline void MemOperate_RedisOperate::set_key_name(const void* value, size_t size) {
  set_has_key_name();
  key_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:DataMem.MemOperate.RedisOperate.key_name)
}
inline ::std::string* MemOperate_RedisOperate::mutable_key_name() {
  set_has_key_name();
  // @@protoc_insertion_point(field_mutable:DataMem.MemOperate.RedisOperate.key_name)
  return key_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* MemOperate_RedisOperate::release_key_name() {
  // @@protoc_insertion_point(field_release:DataMem.MemOperate.RedisOperate.key_name)
  if (!has_key_name()) {
    return NULL;
  }
  clear_has_key_name();
  return key_name_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void MemOperate_RedisOperate::set_allocated_key_name(::std::string* key_name) {
  if (key_name != NULL) {
    set_has_key_name();
  } else {
    clear_has_key_name();
  }
  key_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), key_name);
  // @@protoc_insertion_point(field_set_allocated:DataMem.MemOperate.RedisOperate.key_name)
}

// optional string redis_cmd_read = 2;
inline bool MemOperate_RedisOperate::has_redis_cmd_read() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MemOperate_RedisOperate::set_has_redis_cmd_read() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MemOperate_RedisOperate::clear_has_redis_cmd_read() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MemOperate_RedisOperate::clear_redis_cmd_read() {
  redis_cmd_read_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_redis_cmd_read();
}
inline const ::std::string& MemOperate_RedisOperate::redis_cmd_read() const {
  // @@protoc_insertion_point(field_get:DataMem.MemOperate.RedisOperate.redis_cmd_read)
  return redis_cmd_read_.GetNoArena();
}
inline void MemOperate_RedisOperate::set_redis_cmd_read(const ::std::string& value) {
  set_has_redis_cmd_read();
  redis_cmd_read_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:DataMem.MemOperate.RedisOperate.redis_cmd_read)
}
#if LANG_CXX11
inline void MemOperate_RedisOperate::set_redis_cmd_read(::std::string&& value) {
  set_has_redis_cmd_read();
  redis_cmd_read_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:DataMem.MemOperate.RedisOperate.redis_cmd_read)
}
#endif
inline void MemOperate_RedisOperate::set_redis_cmd_read(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_redis_cmd_read();
  redis_cmd_read_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:DataMem.MemOperate.RedisOperate.redis_cmd_read)
}
inline void MemOperate_RedisOperate::set_redis_cmd_read(const char* value, size_t size) {
  set_has_redis_cmd_read();
  redis_cmd_read_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:DataMem.MemOperate.RedisOperate.redis_cmd_read)
}
inline ::std::string* MemOperate_RedisOperate::mutable_redis_cmd_read() {
  set_has_redis_cmd_read();
  // @@protoc_insertion_point(field_mutable:DataMem.MemOperate.RedisOperate.redis_cmd_read)
  return redis_cmd_read_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* MemOperate_RedisOperate::release_redis_cmd_read() {
  // @@protoc_insertion_point(field_release:DataMem.MemOperate.RedisOperate.redis_cmd_read)
  if (!has_redis_cmd_read()) {
    return NULL;
  }
  clear_has_redis_cmd_read();
  return redis_cmd_read_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void MemOperate_RedisOperate::set_allocated_redis_cmd_read(::std::string* redis_cmd_read) {
  if (redis_cmd_read != NULL) {
    set_has_redis_cmd_read();
  } else {
    clear_has_redis_cmd_read();
  }
  redis_cmd_read_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), redis_cmd_read);
  // @@protoc_insertion_point(field_set_allocated:DataMem.MemOperate.RedisOperate.redis_cmd_read)
}

// optional string redis_cmd_write = 3;
inline bool MemOperate_RedisOperate::has_redis_cmd_write() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MemOperate_RedisOperate::set_has_redis_cmd_write() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MemOperate_RedisOperate::clear_has_redis_cmd_write() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MemOperate_RedisOperate::clear_redis_cmd_write() {
  redis_cmd_write_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_redis_cmd_write();
}
inline const ::std::string& MemOperate_RedisOperate::redis_cmd_write() const {
  // @@protoc_insertion_point(field_get:DataMem.MemOperate.RedisOperate.redis_cmd_write)
  return redis_cmd_write_.GetNoArena();
}
inline void MemOperate_RedisOperate::set_redis_cmd_write(const ::std::string& value) {
  set_has_redis_cmd_write();
  redis_cmd_write_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:DataMem.MemOperate.RedisOperate.redis_cmd_write)
}
#if LANG_CXX11
inline void MemOperate_RedisOperate::set_redis_cmd_write(::std::string&& value) {
  set_has_redis_cmd_write();
  redis_cmd_write_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:DataMem.MemOperate.RedisOperate.redis_cmd_write)
}
#endif
inline void MemOperate_RedisOperate::set_redis_cmd_write(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_redis_cmd_write();
  redis_cmd_write_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:DataMem.MemOperate.RedisOperate.redis_cmd_write)
}
inline void MemOperate_RedisOperate::set_redis_cmd_write(const char* value, size_t size) {
  set_has_redis_cmd_write();
  redis_cmd_write_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:DataMem.MemOperate.RedisOperate.redis_cmd_write)
}
inline ::std::string* MemOperate_RedisOperate::mutable_redis_cmd_write() {
  set_has_redis_cmd_write();
  // @@protoc_insertion_point(field_mutable:DataMem.MemOperate.RedisOperate.redis_cmd_write)
  return redis_cmd_write_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* MemOperate_RedisOperate::release_redis_cmd_write() {
  // @@protoc_insertion_point(field_release:DataMem.MemOperate.RedisOperate.redis_cmd_write)
  if (!has_redis_cmd_write()) {
    return NULL;
  }
  clear_has_redis_cmd_write();
  return redis_cmd_write_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void MemOperate_RedisOperate::set_allocated_redis_cmd_write(::std::string* redis_cmd_write) {
  if (redis_cmd_write != NULL) {
    set_has_redis_cmd_write();
  } else {
    clear_has_redis_cmd_write();
  }
  redis_cmd_write_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), redis_cmd_write);
  // @@protoc_insertion_point(field_set_allocated:DataMem.MemOperate.RedisOperate.redis_cmd_write)
}

// optional .DataMem.MemOperate.RedisOperate.OPERATE_TYPE op_type = 4;
inline bool MemOperate_RedisOperate::has_op_type() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void MemOperate_RedisOperate::set_has_op_type() {
  _has_bits_[0] |= 0x00000010u;
}
inline void MemOperate_RedisOperate::clear_has_op_type() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void MemOperate_RedisOperate::clear_op_type() {
  op_type_ = 0;
  clear_has_op_type();
}
inline ::DataMem::MemOperate_RedisOperate_OPERATE_TYPE MemOperate_RedisOperate::op_type() const {
  // @@protoc_insertion_point(field_get:DataMem.MemOperate.RedisOperate.op_type)
  return static_cast< ::DataMem::MemOperate_RedisOperate_OPERATE_TYPE >(op_type_);
}
inline void MemOperate_RedisOperate::set_op_type(::DataMem::MemOperate_RedisOperate_OPERATE_TYPE value) {
  assert(::DataMem::MemOperate_RedisOperate_OPERATE_TYPE_IsValid(value));
  set_has_op_type();
  op_type_ = value;
  // @@protoc_insertion_point(field_set:DataMem.MemOperate.RedisOperate.op_type)
}

// repeated .DataMem.Field fields = 5;
inline int MemOperate_RedisOperate::fields_size() const {
  return fields_.size();
}
inline void MemOperate_RedisOperate::clear_fields() {
  fields_.Clear();
}
inline ::DataMem::Field* MemOperate_RedisOperate::mutable_fields(int index) {
  // @@protoc_insertion_point(field_mutable:DataMem.MemOperate.RedisOperate.fields)
  return fields_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::DataMem::Field >*
MemOperate_RedisOperate::mutable_fields() {
  // @@protoc_insertion_point(field_mutable_list:DataMem.MemOperate.RedisOperate.fields)
  return &fields_;
}
inline const ::DataMem::Field& MemOperate_RedisOperate::fields(int index) const {
  // @@protoc_insertion_point(field_get:DataMem.MemOperate.RedisOperate.fields)
  return fields_.Get(index);
}
inline ::DataMem::Field* MemOperate_RedisOperate::add_fields() {
  // @@protoc_insertion_point(field_add:DataMem.MemOperate.RedisOperate.fields)
  return fields_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::DataMem::Field >&
MemOperate_RedisOperate::fields() const {
  // @@protoc_insertion_point(field_list:DataMem.MemOperate.RedisOperate.fields)
  return fields_;
}

// optional int32 key_ttl = 6;
inline bool MemOperate_RedisOperate::has_key_ttl() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void MemOperate_RedisOperate::set_has_key_ttl() {
  _has_bits_[0] |= 0x00000020u;
}
inline void MemOperate_RedisOperate::clear_has_key_ttl() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void MemOperate_RedisOperate::clear_key_ttl() {
  key_ttl_ = 0;
  clear_has_key_ttl();
}
inline ::google::protobuf::int32 MemOperate_RedisOperate::key_ttl() const {
  // @@protoc_insertion_point(field_get:DataMem.MemOperate.RedisOperate.key_ttl)
  return key_ttl_;
}
inline void MemOperate_RedisOperate::set_key_ttl(::google::protobuf::int32 value) {
  set_has_key_ttl();
  key_ttl_ = value;
  // @@protoc_insertion_point(field_set:DataMem.MemOperate.RedisOperate.key_ttl)
}

// optional int32 redis_structure = 7;
inline bool MemOperate_RedisOperate::has_redis_structure() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void MemOperate_RedisOperate::set_has_redis_structure() {
  _has_bits_[0] |= 0x00000040u;
}
inline void MemOperate_RedisOperate::clear_has_redis_structure() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void MemOperate_RedisOperate::clear_redis_structure() {
  redis_structure_ = 0;
  clear_has_redis_structure();
}
inline ::google::protobuf::int32 MemOperate_RedisOperate::redis_structure() const {
  // @@protoc_insertion_point(field_get:DataMem.MemOperate.RedisOperate.redis_structure)
  return redis_structure_;
}
inline void MemOperate_RedisOperate::set_redis_structure(::google::protobuf::int32 value) {
  set_has_redis_structure();
  redis_structure_ = value;
  // @@protoc_insertion_point(field_set:DataMem.MemOperate.RedisOperate.redis_structure)
}

// optional int32 data_purpose = 8;
inline bool MemOperate_RedisOperate::has_data_purpose() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void MemOperate_RedisOperate::set_has_data_purpose() {
  _has_bits_[0] |= 0x00000080u;
}
inline void MemOperate_RedisOperate::clear_has_data_purpose() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void MemOperate_RedisOperate::clear_data_purpose() {
  data_purpose_ = 0;
  clear_has_data_purpose();
}
inline ::google::protobuf::int32 MemOperate_RedisOperate::data_purpose() const {
  // @@protoc_insertion_point(field_get:DataMem.MemOperate.RedisOperate.data_purpose)
  return data_purpose_;
}
inline void MemOperate_RedisOperate::set_data_purpose(::google::protobuf::int32 value) {
  set_has_data_purpose();
  data_purpose_ = value;
  // @@protoc_insertion_point(field_set:DataMem.MemOperate.RedisOperate.data_purpose)
}

// optional bytes hash_key = 9;
inline bool MemOperate_RedisOperate::has_hash_key() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void MemOperate_RedisOperate::set_has_hash_key() {
  _has_bits_[0] |= 0x00000008u;
}
inline void MemOperate_RedisOperate::clear_has_hash_key() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void MemOperate_RedisOperate::clear_hash_key() {
  hash_key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_hash_key();
}
inline const ::std::string& MemOperate_RedisOperate::hash_key() const {
  // @@protoc_insertion_point(field_get:DataMem.MemOperate.RedisOperate.hash_key)
  return hash_key_.GetNoArena();
}
inline void MemOperate_RedisOperate::set_hash_key(const ::std::string& value) {
  set_has_hash_key();
  hash_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:DataMem.MemOperate.RedisOperate.hash_key)
}
#if LANG_CXX11
inline void MemOperate_RedisOperate::set_hash_key(::std::string&& value) {
  set_has_hash_key();
  hash_key_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:DataMem.MemOperate.RedisOperate.hash_key)
}
#endif
inline void MemOperate_RedisOperate::set_hash_key(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_hash_key();
  hash_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:DataMem.MemOperate.RedisOperate.hash_key)
}
inline void MemOperate_RedisOperate::set_hash_key(const void* value, size_t size) {
  set_has_hash_key();
  hash_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:DataMem.MemOperate.RedisOperate.hash_key)
}
inline ::std::string* MemOperate_RedisOperate::mutable_hash_key() {
  set_has_hash_key();
  // @@protoc_insertion_point(field_mutable:DataMem.MemOperate.RedisOperate.hash_key)
  return hash_key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* MemOperate_RedisOperate::release_hash_key() {
  // @@protoc_insertion_point(field_release:DataMem.MemOperate.RedisOperate.hash_key)
  if (!has_hash_key()) {
    return NULL;
  }
  clear_has_hash_key();
  return hash_key_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void MemOperate_RedisOperate::set_allocated_hash_key(::std::string* hash_key) {
  if (hash_key != NULL) {
    set_has_hash_key();
  } else {
    clear_has_hash_key();
  }
  hash_key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), hash_key);
  // @@protoc_insertion_point(field_set_allocated:DataMem.MemOperate.RedisOperate.hash_key)
}

// -------------------------------------------------------------------

// MemOperate_DbOperate_Condition

// optional .DataMem.MemOperate.DbOperate.Condition.E_RELATION relation = 1;
inline bool MemOperate_DbOperate_Condition::has_relation() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MemOperate_DbOperate_Condition::set_has_relation() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MemOperate_DbOperate_Condition::clear_has_relation() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MemOperate_DbOperate_Condition::clear_relation() {
  relation_ = 0;
  clear_has_relation();
}
inline ::DataMem::MemOperate_DbOperate_Condition_E_RELATION MemOperate_DbOperate_Condition::relation() const {
  // @@protoc_insertion_point(field_get:DataMem.MemOperate.DbOperate.Condition.relation)
  return static_cast< ::DataMem::MemOperate_DbOperate_Condition_E_RELATION >(relation_);
}
inline void MemOperate_DbOperate_Condition::set_relation(::DataMem::MemOperate_DbOperate_Condition_E_RELATION value) {
  assert(::DataMem::MemOperate_DbOperate_Condition_E_RELATION_IsValid(value));
  set_has_relation();
  relation_ = value;
  // @@protoc_insertion_point(field_set:DataMem.MemOperate.DbOperate.Condition.relation)
}

// optional .DataMem.E_COL_TYPE col_type = 2;
inline bool MemOperate_DbOperate_Condition::has_col_type() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void MemOperate_DbOperate_Condition::set_has_col_type() {
  _has_bits_[0] |= 0x00000008u;
}
inline void MemOperate_DbOperate_Condition::clear_has_col_type() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void MemOperate_DbOperate_Condition::clear_col_type() {
  col_type_ = 0;
  clear_has_col_type();
}
inline ::DataMem::E_COL_TYPE MemOperate_DbOperate_Condition::col_type() const {
  // @@protoc_insertion_point(field_get:DataMem.MemOperate.DbOperate.Condition.col_type)
  return static_cast< ::DataMem::E_COL_TYPE >(col_type_);
}
inline void MemOperate_DbOperate_Condition::set_col_type(::DataMem::E_COL_TYPE value) {
  assert(::DataMem::E_COL_TYPE_IsValid(value));
  set_has_col_type();
  col_type_ = value;
  // @@protoc_insertion_point(field_set:DataMem.MemOperate.DbOperate.Condition.col_type)
}

// optional string col_name = 3;
inline bool MemOperate_DbOperate_Condition::has_col_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MemOperate_DbOperate_Condition::set_has_col_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MemOperate_DbOperate_Condition::clear_has_col_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MemOperate_DbOperate_Condition::clear_col_name() {
  col_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_col_name();
}
inline const ::std::string& MemOperate_DbOperate_Condition::col_name() const {
  // @@protoc_insertion_point(field_get:DataMem.MemOperate.DbOperate.Condition.col_name)
  return col_name_.GetNoArena();
}
inline void MemOperate_DbOperate_Condition::set_col_name(const ::std::string& value) {
  set_has_col_name();
  col_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:DataMem.MemOperate.DbOperate.Condition.col_name)
}
#if LANG_CXX11
inline void MemOperate_DbOperate_Condition::set_col_name(::std::string&& value) {
  set_has_col_name();
  col_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:DataMem.MemOperate.DbOperate.Condition.col_name)
}
#endif
inline void MemOperate_DbOperate_Condition::set_col_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_col_name();
  col_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:DataMem.MemOperate.DbOperate.Condition.col_name)
}
inline void MemOperate_DbOperate_Condition::set_col_name(const char* value, size_t size) {
  set_has_col_name();
  col_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:DataMem.MemOperate.DbOperate.Condition.col_name)
}
inline ::std::string* MemOperate_DbOperate_Condition::mutable_col_name() {
  set_has_col_name();
  // @@protoc_insertion_point(field_mutable:DataMem.MemOperate.DbOperate.Condition.col_name)
  return col_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* MemOperate_DbOperate_Condition::release_col_name() {
  // @@protoc_insertion_point(field_release:DataMem.MemOperate.DbOperate.Condition.col_name)
  if (!has_col_name()) {
    return NULL;
  }
  clear_has_col_name();
  return col_name_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void MemOperate_DbOperate_Condition::set_allocated_col_name(::std::string* col_name) {
  if (col_name != NULL) {
    set_has_col_name();
  } else {
    clear_has_col_name();
  }
  col_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), col_name);
  // @@protoc_insertion_point(field_set_allocated:DataMem.MemOperate.DbOperate.Condition.col_name)
}

// repeated bytes col_values = 4;
inline int MemOperate_DbOperate_Condition::col_values_size() const {
  return col_values_.size();
}
inline void MemOperate_DbOperate_Condition::clear_col_values() {
  col_values_.Clear();
}
inline const ::std::string& MemOperate_DbOperate_Condition::col_values(int index) const {
  // @@protoc_insertion_point(field_get:DataMem.MemOperate.DbOperate.Condition.col_values)
  return col_values_.Get(index);
}
inline ::std::string* MemOperate_DbOperate_Condition::mutable_col_values(int index) {
  // @@protoc_insertion_point(field_mutable:DataMem.MemOperate.DbOperate.Condition.col_values)
  return col_values_.Mutable(index);
}
inline void MemOperate_DbOperate_Condition::set_col_values(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:DataMem.MemOperate.DbOperate.Condition.col_values)
  col_values_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void MemOperate_DbOperate_Condition::set_col_values(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:DataMem.MemOperate.DbOperate.Condition.col_values)
  col_values_.Mutable(index)->assign(std::move(value));
}
#endif
inline void MemOperate_DbOperate_Condition::set_col_values(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  col_values_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:DataMem.MemOperate.DbOperate.Condition.col_values)
}
inline void MemOperate_DbOperate_Condition::set_col_values(int index, const void* value, size_t size) {
  col_values_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:DataMem.MemOperate.DbOperate.Condition.col_values)
}
inline ::std::string* MemOperate_DbOperate_Condition::add_col_values() {
  // @@protoc_insertion_point(field_add_mutable:DataMem.MemOperate.DbOperate.Condition.col_values)
  return col_values_.Add();
}
inline void MemOperate_DbOperate_Condition::add_col_values(const ::std::string& value) {
  col_values_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:DataMem.MemOperate.DbOperate.Condition.col_values)
}
#if LANG_CXX11
inline void MemOperate_DbOperate_Condition::add_col_values(::std::string&& value) {
  col_values_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:DataMem.MemOperate.DbOperate.Condition.col_values)
}
#endif
inline void MemOperate_DbOperate_Condition::add_col_values(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  col_values_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:DataMem.MemOperate.DbOperate.Condition.col_values)
}
inline void MemOperate_DbOperate_Condition::add_col_values(const void* value, size_t size) {
  col_values_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:DataMem.MemOperate.DbOperate.Condition.col_values)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
MemOperate_DbOperate_Condition::col_values() const {
  // @@protoc_insertion_point(field_list:DataMem.MemOperate.DbOperate.Condition.col_values)
  return col_values_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
MemOperate_DbOperate_Condition::mutable_col_values() {
  // @@protoc_insertion_point(field_mutable_list:DataMem.MemOperate.DbOperate.Condition.col_values)
  return &col_values_;
}

// optional string col_name_right = 5;
inline bool MemOperate_DbOperate_Condition::has_col_name_right() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MemOperate_DbOperate_Condition::set_has_col_name_right() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MemOperate_DbOperate_Condition::clear_has_col_name_right() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MemOperate_DbOperate_Condition::clear_col_name_right() {
  col_name_right_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_col_name_right();
}
inline const ::std::string& MemOperate_DbOperate_Condition::col_name_right() const {
  // @@protoc_insertion_point(field_get:DataMem.MemOperate.DbOperate.Condition.col_name_right)
  return col_name_right_.GetNoArena();
}
inline void MemOperate_DbOperate_Condition::set_col_name_right(const ::std::string& value) {
  set_has_col_name_right();
  col_name_right_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:DataMem.MemOperate.DbOperate.Condition.col_name_right)
}
#if LANG_CXX11
inline void MemOperate_DbOperate_Condition::set_col_name_right(::std::string&& value) {
  set_has_col_name_right();
  col_name_right_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:DataMem.MemOperate.DbOperate.Condition.col_name_right)
}
#endif
inline void MemOperate_DbOperate_Condition::set_col_name_right(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_col_name_right();
  col_name_right_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:DataMem.MemOperate.DbOperate.Condition.col_name_right)
}
inline void MemOperate_DbOperate_Condition::set_col_name_right(const char* value, size_t size) {
  set_has_col_name_right();
  col_name_right_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:DataMem.MemOperate.DbOperate.Condition.col_name_right)
}
inline ::std::string* MemOperate_DbOperate_Condition::mutable_col_name_right() {
  set_has_col_name_right();
  // @@protoc_insertion_point(field_mutable:DataMem.MemOperate.DbOperate.Condition.col_name_right)
  return col_name_right_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* MemOperate_DbOperate_Condition::release_col_name_right() {
  // @@protoc_insertion_point(field_release:DataMem.MemOperate.DbOperate.Condition.col_name_right)
  if (!has_col_name_right()) {
    return NULL;
  }
  clear_has_col_name_right();
  return col_name_right_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void MemOperate_DbOperate_Condition::set_allocated_col_name_right(::std::string* col_name_right) {
  if (col_name_right != NULL) {
    set_has_col_name_right();
  } else {
    clear_has_col_name_right();
  }
  col_name_right_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), col_name_right);
  // @@protoc_insertion_point(field_set_allocated:DataMem.MemOperate.DbOperate.Condition.col_name_right)
}

// -------------------------------------------------------------------

// MemOperate_DbOperate_ConditionGroup

// optional .DataMem.MemOperate.DbOperate.ConditionGroup.E_RELATION relation = 1;
inline bool MemOperate_DbOperate_ConditionGroup::has_relation() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MemOperate_DbOperate_ConditionGroup::set_has_relation() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MemOperate_DbOperate_ConditionGroup::clear_has_relation() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MemOperate_DbOperate_ConditionGroup::clear_relation() {
  relation_ = 0;
  clear_has_relation();
}
inline ::DataMem::MemOperate_DbOperate_ConditionGroup_E_RELATION MemOperate_DbOperate_ConditionGroup::relation() const {
  // @@protoc_insertion_point(field_get:DataMem.MemOperate.DbOperate.ConditionGroup.relation)
  return static_cast< ::DataMem::MemOperate_DbOperate_ConditionGroup_E_RELATION >(relation_);
}
inline void MemOperate_DbOperate_ConditionGroup::set_relation(::DataMem::MemOperate_DbOperate_ConditionGroup_E_RELATION value) {
  assert(::DataMem::MemOperate_DbOperate_ConditionGroup_E_RELATION_IsValid(value));
  set_has_relation();
  relation_ = value;
  // @@protoc_insertion_point(field_set:DataMem.MemOperate.DbOperate.ConditionGroup.relation)
}

// repeated .DataMem.MemOperate.DbOperate.Condition condition = 2;
inline int MemOperate_DbOperate_ConditionGroup::condition_size() const {
  return condition_.size();
}
inline void MemOperate_DbOperate_ConditionGroup::clear_condition() {
  condition_.Clear();
}
inline ::DataMem::MemOperate_DbOperate_Condition* MemOperate_DbOperate_ConditionGroup::mutable_condition(int index) {
  // @@protoc_insertion_point(field_mutable:DataMem.MemOperate.DbOperate.ConditionGroup.condition)
  return condition_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::DataMem::MemOperate_DbOperate_Condition >*
MemOperate_DbOperate_ConditionGroup::mutable_condition() {
  // @@protoc_insertion_point(field_mutable_list:DataMem.MemOperate.DbOperate.ConditionGroup.condition)
  return &condition_;
}
inline const ::DataMem::MemOperate_DbOperate_Condition& MemOperate_DbOperate_ConditionGroup::condition(int index) const {
  // @@protoc_insertion_point(field_get:DataMem.MemOperate.DbOperate.ConditionGroup.condition)
  return condition_.Get(index);
}
inline ::DataMem::MemOperate_DbOperate_Condition* MemOperate_DbOperate_ConditionGroup::add_condition() {
  // @@protoc_insertion_point(field_add:DataMem.MemOperate.DbOperate.ConditionGroup.condition)
  return condition_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::DataMem::MemOperate_DbOperate_Condition >&
MemOperate_DbOperate_ConditionGroup::condition() const {
  // @@protoc_insertion_point(field_list:DataMem.MemOperate.DbOperate.ConditionGroup.condition)
  return condition_;
}

// -------------------------------------------------------------------

// MemOperate_DbOperate_OrderBy

// optional .DataMem.MemOperate.DbOperate.OrderBy.E_RELATION relation = 1;
inline bool MemOperate_DbOperate_OrderBy::has_relation() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MemOperate_DbOperate_OrderBy::set_has_relation() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MemOperate_DbOperate_OrderBy::clear_has_relation() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MemOperate_DbOperate_OrderBy::clear_relation() {
  relation_ = 0;
  clear_has_relation();
}
inline ::DataMem::MemOperate_DbOperate_OrderBy_E_RELATION MemOperate_DbOperate_OrderBy::relation() const {
  // @@protoc_insertion_point(field_get:DataMem.MemOperate.DbOperate.OrderBy.relation)
  return static_cast< ::DataMem::MemOperate_DbOperate_OrderBy_E_RELATION >(relation_);
}
inline void MemOperate_DbOperate_OrderBy::set_relation(::DataMem::MemOperate_DbOperate_OrderBy_E_RELATION value) {
  assert(::DataMem::MemOperate_DbOperate_OrderBy_E_RELATION_IsValid(value));
  set_has_relation();
  relation_ = value;
  // @@protoc_insertion_point(field_set:DataMem.MemOperate.DbOperate.OrderBy.relation)
}

// optional string col_name = 2;
inline bool MemOperate_DbOperate_OrderBy::has_col_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MemOperate_DbOperate_OrderBy::set_has_col_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MemOperate_DbOperate_OrderBy::clear_has_col_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MemOperate_DbOperate_OrderBy::clear_col_name() {
  col_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_col_name();
}
inline const ::std::string& MemOperate_DbOperate_OrderBy::col_name() const {
  // @@protoc_insertion_point(field_get:DataMem.MemOperate.DbOperate.OrderBy.col_name)
  return col_name_.GetNoArena();
}
inline void MemOperate_DbOperate_OrderBy::set_col_name(const ::std::string& value) {
  set_has_col_name();
  col_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:DataMem.MemOperate.DbOperate.OrderBy.col_name)
}
#if LANG_CXX11
inline void MemOperate_DbOperate_OrderBy::set_col_name(::std::string&& value) {
  set_has_col_name();
  col_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:DataMem.MemOperate.DbOperate.OrderBy.col_name)
}
#endif
inline void MemOperate_DbOperate_OrderBy::set_col_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_col_name();
  col_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:DataMem.MemOperate.DbOperate.OrderBy.col_name)
}
inline void MemOperate_DbOperate_OrderBy::set_col_name(const char* value, size_t size) {
  set_has_col_name();
  col_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:DataMem.MemOperate.DbOperate.OrderBy.col_name)
}
inline ::std::string* MemOperate_DbOperate_OrderBy::mutable_col_name() {
  set_has_col_name();
  // @@protoc_insertion_point(field_mutable:DataMem.MemOperate.DbOperate.OrderBy.col_name)
  return col_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* MemOperate_DbOperate_OrderBy::release_col_name() {
  // @@protoc_insertion_point(field_release:DataMem.MemOperate.DbOperate.OrderBy.col_name)
  if (!has_col_name()) {
    return NULL;
  }
  clear_has_col_name();
  return col_name_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void MemOperate_DbOperate_OrderBy::set_allocated_col_name(::std::string* col_name) {
  if (col_name != NULL) {
    set_has_col_name();
  } else {
    clear_has_col_name();
  }
  col_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), col_name);
  // @@protoc_insertion_point(field_set_allocated:DataMem.MemOperate.DbOperate.OrderBy.col_name)
}

// -------------------------------------------------------------------

// MemOperate_DbOperate

// optional .DataMem.MemOperate.DbOperate.E_QUERY_TYPE query_type = 1;
inline bool MemOperate_DbOperate::has_query_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MemOperate_DbOperate::set_has_query_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MemOperate_DbOperate::clear_has_query_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MemOperate_DbOperate::clear_query_type() {
  query_type_ = 0;
  clear_has_query_type();
}
inline ::DataMem::MemOperate_DbOperate_E_QUERY_TYPE MemOperate_DbOperate::query_type() const {
  // @@protoc_insertion_point(field_get:DataMem.MemOperate.DbOperate.query_type)
  return static_cast< ::DataMem::MemOperate_DbOperate_E_QUERY_TYPE >(query_type_);
}
inline void MemOperate_DbOperate::set_query_type(::DataMem::MemOperate_DbOperate_E_QUERY_TYPE value) {
  assert(::DataMem::MemOperate_DbOperate_E_QUERY_TYPE_IsValid(value));
  set_has_query_type();
  query_type_ = value;
  // @@protoc_insertion_point(field_set:DataMem.MemOperate.DbOperate.query_type)
}

// optional string table_name = 2;
inline bool MemOperate_DbOperate::has_table_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MemOperate_DbOperate::set_has_table_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MemOperate_DbOperate::clear_has_table_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MemOperate_DbOperate::clear_table_name() {
  table_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_table_name();
}
inline const ::std::string& MemOperate_DbOperate::table_name() const {
  // @@protoc_insertion_point(field_get:DataMem.MemOperate.DbOperate.table_name)
  return table_name_.GetNoArena();
}
inline void MemOperate_DbOperate::set_table_name(const ::std::string& value) {
  set_has_table_name();
  table_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:DataMem.MemOperate.DbOperate.table_name)
}
#if LANG_CXX11
inline void MemOperate_DbOperate::set_table_name(::std::string&& value) {
  set_has_table_name();
  table_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:DataMem.MemOperate.DbOperate.table_name)
}
#endif
inline void MemOperate_DbOperate::set_table_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_table_name();
  table_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:DataMem.MemOperate.DbOperate.table_name)
}
inline void MemOperate_DbOperate::set_table_name(const char* value, size_t size) {
  set_has_table_name();
  table_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:DataMem.MemOperate.DbOperate.table_name)
}
inline ::std::string* MemOperate_DbOperate::mutable_table_name() {
  set_has_table_name();
  // @@protoc_insertion_point(field_mutable:DataMem.MemOperate.DbOperate.table_name)
  return table_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* MemOperate_DbOperate::release_table_name() {
  // @@protoc_insertion_point(field_release:DataMem.MemOperate.DbOperate.table_name)
  if (!has_table_name()) {
    return NULL;
  }
  clear_has_table_name();
  return table_name_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void MemOperate_DbOperate::set_allocated_table_name(::std::string* table_name) {
  if (table_name != NULL) {
    set_has_table_name();
  } else {
    clear_has_table_name();
  }
  table_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), table_name);
  // @@protoc_insertion_point(field_set_allocated:DataMem.MemOperate.DbOperate.table_name)
}

// repeated .DataMem.Field fields = 3;
inline int MemOperate_DbOperate::fields_size() const {
  return fields_.size();
}
inline void MemOperate_DbOperate::clear_fields() {
  fields_.Clear();
}
inline ::DataMem::Field* MemOperate_DbOperate::mutable_fields(int index) {
  // @@protoc_insertion_point(field_mutable:DataMem.MemOperate.DbOperate.fields)
  return fields_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::DataMem::Field >*
MemOperate_DbOperate::mutable_fields() {
  // @@protoc_insertion_point(field_mutable_list:DataMem.MemOperate.DbOperate.fields)
  return &fields_;
}
inline const ::DataMem::Field& MemOperate_DbOperate::fields(int index) const {
  // @@protoc_insertion_point(field_get:DataMem.MemOperate.DbOperate.fields)
  return fields_.Get(index);
}
inline ::DataMem::Field* MemOperate_DbOperate::add_fields() {
  // @@protoc_insertion_point(field_add:DataMem.MemOperate.DbOperate.fields)
  return fields_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::DataMem::Field >&
MemOperate_DbOperate::fields() const {
  // @@protoc_insertion_point(field_list:DataMem.MemOperate.DbOperate.fields)
  return fields_;
}

// repeated .DataMem.MemOperate.DbOperate.ConditionGroup conditions = 4;
inline int MemOperate_DbOperate::conditions_size() const {
  return conditions_.size();
}
inline void MemOperate_DbOperate::clear_conditions() {
  conditions_.Clear();
}
inline ::DataMem::MemOperate_DbOperate_ConditionGroup* MemOperate_DbOperate::mutable_conditions(int index) {
  // @@protoc_insertion_point(field_mutable:DataMem.MemOperate.DbOperate.conditions)
  return conditions_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::DataMem::MemOperate_DbOperate_ConditionGroup >*
MemOperate_DbOperate::mutable_conditions() {
  // @@protoc_insertion_point(field_mutable_list:DataMem.MemOperate.DbOperate.conditions)
  return &conditions_;
}
inline const ::DataMem::MemOperate_DbOperate_ConditionGroup& MemOperate_DbOperate::conditions(int index) const {
  // @@protoc_insertion_point(field_get:DataMem.MemOperate.DbOperate.conditions)
  return conditions_.Get(index);
}
inline ::DataMem::MemOperate_DbOperate_ConditionGroup* MemOperate_DbOperate::add_conditions() {
  // @@protoc_insertion_point(field_add:DataMem.MemOperate.DbOperate.conditions)
  return conditions_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::DataMem::MemOperate_DbOperate_ConditionGroup >&
MemOperate_DbOperate::conditions() const {
  // @@protoc_insertion_point(field_list:DataMem.MemOperate.DbOperate.conditions)
  return conditions_;
}

// repeated string groupby_col = 5;
inline int MemOperate_DbOperate::groupby_col_size() const {
  return groupby_col_.size();
}
inline void MemOperate_DbOperate::clear_groupby_col() {
  groupby_col_.Clear();
}
inline const ::std::string& MemOperate_DbOperate::groupby_col(int index) const {
  // @@protoc_insertion_point(field_get:DataMem.MemOperate.DbOperate.groupby_col)
  return groupby_col_.Get(index);
}
inline ::std::string* MemOperate_DbOperate::mutable_groupby_col(int index) {
  // @@protoc_insertion_point(field_mutable:DataMem.MemOperate.DbOperate.groupby_col)
  return groupby_col_.Mutable(index);
}
inline void MemOperate_DbOperate::set_groupby_col(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:DataMem.MemOperate.DbOperate.groupby_col)
  groupby_col_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void MemOperate_DbOperate::set_groupby_col(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:DataMem.MemOperate.DbOperate.groupby_col)
  groupby_col_.Mutable(index)->assign(std::move(value));
}
#endif
inline void MemOperate_DbOperate::set_groupby_col(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  groupby_col_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:DataMem.MemOperate.DbOperate.groupby_col)
}
inline void MemOperate_DbOperate::set_groupby_col(int index, const char* value, size_t size) {
  groupby_col_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:DataMem.MemOperate.DbOperate.groupby_col)
}
inline ::std::string* MemOperate_DbOperate::add_groupby_col() {
  // @@protoc_insertion_point(field_add_mutable:DataMem.MemOperate.DbOperate.groupby_col)
  return groupby_col_.Add();
}
inline void MemOperate_DbOperate::add_groupby_col(const ::std::string& value) {
  groupby_col_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:DataMem.MemOperate.DbOperate.groupby_col)
}
#if LANG_CXX11
inline void MemOperate_DbOperate::add_groupby_col(::std::string&& value) {
  groupby_col_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:DataMem.MemOperate.DbOperate.groupby_col)
}
#endif
inline void MemOperate_DbOperate::add_groupby_col(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  groupby_col_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:DataMem.MemOperate.DbOperate.groupby_col)
}
inline void MemOperate_DbOperate::add_groupby_col(const char* value, size_t size) {
  groupby_col_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:DataMem.MemOperate.DbOperate.groupby_col)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
MemOperate_DbOperate::groupby_col() const {
  // @@protoc_insertion_point(field_list:DataMem.MemOperate.DbOperate.groupby_col)
  return groupby_col_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
MemOperate_DbOperate::mutable_groupby_col() {
  // @@protoc_insertion_point(field_mutable_list:DataMem.MemOperate.DbOperate.groupby_col)
  return &groupby_col_;
}

// repeated .DataMem.MemOperate.DbOperate.OrderBy orderby_col = 6;
inline int MemOperate_DbOperate::orderby_col_size() const {
  return orderby_col_.size();
}
inline void MemOperate_DbOperate::clear_orderby_col() {
  orderby_col_.Clear();
}
inline ::DataMem::MemOperate_DbOperate_OrderBy* MemOperate_DbOperate::mutable_orderby_col(int index) {
  // @@protoc_insertion_point(field_mutable:DataMem.MemOperate.DbOperate.orderby_col)
  return orderby_col_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::DataMem::MemOperate_DbOperate_OrderBy >*
MemOperate_DbOperate::mutable_orderby_col() {
  // @@protoc_insertion_point(field_mutable_list:DataMem.MemOperate.DbOperate.orderby_col)
  return &orderby_col_;
}
inline const ::DataMem::MemOperate_DbOperate_OrderBy& MemOperate_DbOperate::orderby_col(int index) const {
  // @@protoc_insertion_point(field_get:DataMem.MemOperate.DbOperate.orderby_col)
  return orderby_col_.Get(index);
}
inline ::DataMem::MemOperate_DbOperate_OrderBy* MemOperate_DbOperate::add_orderby_col() {
  // @@protoc_insertion_point(field_add:DataMem.MemOperate.DbOperate.orderby_col)
  return orderby_col_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::DataMem::MemOperate_DbOperate_OrderBy >&
MemOperate_DbOperate::orderby_col() const {
  // @@protoc_insertion_point(field_list:DataMem.MemOperate.DbOperate.orderby_col)
  return orderby_col_;
}

// optional .DataMem.MemOperate.DbOperate.ConditionGroup.E_RELATION group_relation = 7;
inline bool MemOperate_DbOperate::has_group_relation() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MemOperate_DbOperate::set_has_group_relation() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MemOperate_DbOperate::clear_has_group_relation() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MemOperate_DbOperate::clear_group_relation() {
  group_relation_ = 0;
  clear_has_group_relation();
}
inline ::DataMem::MemOperate_DbOperate_ConditionGroup_E_RELATION MemOperate_DbOperate::group_relation() const {
  // @@protoc_insertion_point(field_get:DataMem.MemOperate.DbOperate.group_relation)
  return static_cast< ::DataMem::MemOperate_DbOperate_ConditionGroup_E_RELATION >(group_relation_);
}
inline void MemOperate_DbOperate::set_group_relation(::DataMem::MemOperate_DbOperate_ConditionGroup_E_RELATION value) {
  assert(::DataMem::MemOperate_DbOperate_ConditionGroup_E_RELATION_IsValid(value));
  set_has_group_relation();
  group_relation_ = value;
  // @@protoc_insertion_point(field_set:DataMem.MemOperate.DbOperate.group_relation)
}

// optional uint32 limit = 8;
inline bool MemOperate_DbOperate::has_limit() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void MemOperate_DbOperate::set_has_limit() {
  _has_bits_[0] |= 0x00000008u;
}
inline void MemOperate_DbOperate::clear_has_limit() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void MemOperate_DbOperate::clear_limit() {
  limit_ = 0u;
  clear_has_limit();
}
inline ::google::protobuf::uint32 MemOperate_DbOperate::limit() const {
  // @@protoc_insertion_point(field_get:DataMem.MemOperate.DbOperate.limit)
  return limit_;
}
inline void MemOperate_DbOperate::set_limit(::google::protobuf::uint32 value) {
  set_has_limit();
  limit_ = value;
  // @@protoc_insertion_point(field_set:DataMem.MemOperate.DbOperate.limit)
}

// optional uint32 limit_from = 9;
inline bool MemOperate_DbOperate::has_limit_from() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void MemOperate_DbOperate::set_has_limit_from() {
  _has_bits_[0] |= 0x00000010u;
}
inline void MemOperate_DbOperate::clear_has_limit_from() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void MemOperate_DbOperate::clear_limit_from() {
  limit_from_ = 0u;
  clear_has_limit_from();
}
inline ::google::protobuf::uint32 MemOperate_DbOperate::limit_from() const {
  // @@protoc_insertion_point(field_get:DataMem.MemOperate.DbOperate.limit_from)
  return limit_from_;
}
inline void MemOperate_DbOperate::set_limit_from(::google::protobuf::uint32 value) {
  set_has_limit_from();
  limit_from_ = value;
  // @@protoc_insertion_point(field_set:DataMem.MemOperate.DbOperate.limit_from)
}

// optional uint64 mod_factor = 10;
inline bool MemOperate_DbOperate::has_mod_factor() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void MemOperate_DbOperate::set_has_mod_factor() {
  _has_bits_[0] |= 0x00000020u;
}
inline void MemOperate_DbOperate::clear_has_mod_factor() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void MemOperate_DbOperate::clear_mod_factor() {
  mod_factor_ = GOOGLE_ULONGLONG(0);
  clear_has_mod_factor();
}
inline ::google::protobuf::uint64 MemOperate_DbOperate::mod_factor() const {
  // @@protoc_insertion_point(field_get:DataMem.MemOperate.DbOperate.mod_factor)
  return mod_factor_;
}
inline void MemOperate_DbOperate::set_mod_factor(::google::protobuf::uint64 value) {
  set_has_mod_factor();
  mod_factor_ = value;
  // @@protoc_insertion_point(field_set:DataMem.MemOperate.DbOperate.mod_factor)
}

// -------------------------------------------------------------------

// MemOperate

// optional uint64 section_factor = 1;
inline bool MemOperate::has_section_factor() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MemOperate::set_has_section_factor() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MemOperate::clear_has_section_factor() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MemOperate::clear_section_factor() {
  section_factor_ = GOOGLE_ULONGLONG(0);
  clear_has_section_factor();
}
inline ::google::protobuf::uint64 MemOperate::section_factor() const {
  // @@protoc_insertion_point(field_get:DataMem.MemOperate.section_factor)
  return section_factor_;
}
inline void MemOperate::set_section_factor(::google::protobuf::uint64 value) {
  set_has_section_factor();
  section_factor_ = value;
  // @@protoc_insertion_point(field_set:DataMem.MemOperate.section_factor)
}

// optional .DataMem.MemOperate.RedisOperate redis_operate = 2;
inline bool MemOperate::has_redis_operate() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MemOperate::set_has_redis_operate() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MemOperate::clear_has_redis_operate() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MemOperate::clear_redis_operate() {
  if (redis_operate_ != NULL) redis_operate_->Clear();
  clear_has_redis_operate();
}
inline const ::DataMem::MemOperate_RedisOperate& MemOperate::_internal_redis_operate() const {
  return *redis_operate_;
}
inline const ::DataMem::MemOperate_RedisOperate& MemOperate::redis_operate() const {
  const ::DataMem::MemOperate_RedisOperate* p = redis_operate_;
  // @@protoc_insertion_point(field_get:DataMem.MemOperate.redis_operate)
  return p != NULL ? *p : *reinterpret_cast<const ::DataMem::MemOperate_RedisOperate*>(
      &::DataMem::_MemOperate_RedisOperate_default_instance_);
}
inline ::DataMem::MemOperate_RedisOperate* MemOperate::release_redis_operate() {
  // @@protoc_insertion_point(field_release:DataMem.MemOperate.redis_operate)
  clear_has_redis_operate();
  ::DataMem::MemOperate_RedisOperate* temp = redis_operate_;
  redis_operate_ = NULL;
  return temp;
}
inline ::DataMem::MemOperate_RedisOperate* MemOperate::mutable_redis_operate() {
  set_has_redis_operate();
  if (redis_operate_ == NULL) {
    auto* p = CreateMaybeMessage<::DataMem::MemOperate_RedisOperate>(GetArenaNoVirtual());
    redis_operate_ = p;
  }
  // @@protoc_insertion_point(field_mutable:DataMem.MemOperate.redis_operate)
  return redis_operate_;
}
inline void MemOperate::set_allocated_redis_operate(::DataMem::MemOperate_RedisOperate* redis_operate) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete redis_operate_;
  }
  if (redis_operate) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      redis_operate = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, redis_operate, submessage_arena);
    }
    set_has_redis_operate();
  } else {
    clear_has_redis_operate();
  }
  redis_operate_ = redis_operate;
  // @@protoc_insertion_point(field_set_allocated:DataMem.MemOperate.redis_operate)
}

// optional .DataMem.MemOperate.DbOperate db_operate = 3;
inline bool MemOperate::has_db_operate() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MemOperate::set_has_db_operate() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MemOperate::clear_has_db_operate() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MemOperate::clear_db_operate() {
  if (db_operate_ != NULL) db_operate_->Clear();
  clear_has_db_operate();
}
inline const ::DataMem::MemOperate_DbOperate& MemOperate::_internal_db_operate() const {
  return *db_operate_;
}
inline const ::DataMem::MemOperate_DbOperate& MemOperate::db_operate() const {
  const ::DataMem::MemOperate_DbOperate* p = db_operate_;
  // @@protoc_insertion_point(field_get:DataMem.MemOperate.db_operate)
  return p != NULL ? *p : *reinterpret_cast<const ::DataMem::MemOperate_DbOperate*>(
      &::DataMem::_MemOperate_DbOperate_default_instance_);
}
inline ::DataMem::MemOperate_DbOperate* MemOperate::release_db_operate() {
  // @@protoc_insertion_point(field_release:DataMem.MemOperate.db_operate)
  clear_has_db_operate();
  ::DataMem::MemOperate_DbOperate* temp = db_operate_;
  db_operate_ = NULL;
  return temp;
}
inline ::DataMem::MemOperate_DbOperate* MemOperate::mutable_db_operate() {
  set_has_db_operate();
  if (db_operate_ == NULL) {
    auto* p = CreateMaybeMessage<::DataMem::MemOperate_DbOperate>(GetArenaNoVirtual());
    db_operate_ = p;
  }
  // @@protoc_insertion_point(field_mutable:DataMem.MemOperate.db_operate)
  return db_operate_;
}
inline void MemOperate::set_allocated_db_operate(::DataMem::MemOperate_DbOperate* db_operate) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete db_operate_;
  }
  if (db_operate) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      db_operate = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, db_operate, submessage_arena);
    }
    set_has_db_operate();
  } else {
    clear_has_db_operate();
  }
  db_operate_ = db_operate;
  // @@protoc_insertion_point(field_set_allocated:DataMem.MemOperate.db_operate)
}

// -------------------------------------------------------------------

// Record

// repeated .DataMem.Field field_info = 1;
inline int Record::field_info_size() const {
  return field_info_.size();
}
inline void Record::clear_field_info() {
  field_info_.Clear();
}
inline ::DataMem::Field* Record::mutable_field_info(int index) {
  // @@protoc_insertion_point(field_mutable:DataMem.Record.field_info)
  return field_info_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::DataMem::Field >*
Record::mutable_field_info() {
  // @@protoc_insertion_point(field_mutable_list:DataMem.Record.field_info)
  return &field_info_;
}
inline const ::DataMem::Field& Record::field_info(int index) const {
  // @@protoc_insertion_point(field_get:DataMem.Record.field_info)
  return field_info_.Get(index);
}
inline ::DataMem::Field* Record::add_field_info() {
  // @@protoc_insertion_point(field_add:DataMem.Record.field_info)
  return field_info_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::DataMem::Field >&
Record::field_info() const {
  // @@protoc_insertion_point(field_list:DataMem.Record.field_info)
  return field_info_;
}

// -------------------------------------------------------------------

// Field

// optional string col_name = 1;
inline bool Field::has_col_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Field::set_has_col_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Field::clear_has_col_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Field::clear_col_name() {
  col_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_col_name();
}
inline const ::std::string& Field::col_name() const {
  // @@protoc_insertion_point(field_get:DataMem.Field.col_name)
  return col_name_.GetNoArena();
}
inline void Field::set_col_name(const ::std::string& value) {
  set_has_col_name();
  col_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:DataMem.Field.col_name)
}
#if LANG_CXX11
inline void Field::set_col_name(::std::string&& value) {
  set_has_col_name();
  col_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:DataMem.Field.col_name)
}
#endif
inline void Field::set_col_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_col_name();
  col_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:DataMem.Field.col_name)
}
inline void Field::set_col_name(const char* value, size_t size) {
  set_has_col_name();
  col_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:DataMem.Field.col_name)
}
inline ::std::string* Field::mutable_col_name() {
  set_has_col_name();
  // @@protoc_insertion_point(field_mutable:DataMem.Field.col_name)
  return col_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Field::release_col_name() {
  // @@protoc_insertion_point(field_release:DataMem.Field.col_name)
  if (!has_col_name()) {
    return NULL;
  }
  clear_has_col_name();
  return col_name_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Field::set_allocated_col_name(::std::string* col_name) {
  if (col_name != NULL) {
    set_has_col_name();
  } else {
    clear_has_col_name();
  }
  col_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), col_name);
  // @@protoc_insertion_point(field_set_allocated:DataMem.Field.col_name)
}

// optional .DataMem.E_COL_TYPE col_type = 2;
inline bool Field::has_col_type() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Field::set_has_col_type() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Field::clear_has_col_type() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Field::clear_col_type() {
  col_type_ = 0;
  clear_has_col_type();
}
inline ::DataMem::E_COL_TYPE Field::col_type() const {
  // @@protoc_insertion_point(field_get:DataMem.Field.col_type)
  return static_cast< ::DataMem::E_COL_TYPE >(col_type_);
}
inline void Field::set_col_type(::DataMem::E_COL_TYPE value) {
  assert(::DataMem::E_COL_TYPE_IsValid(value));
  set_has_col_type();
  col_type_ = value;
  // @@protoc_insertion_point(field_set:DataMem.Field.col_type)
}

// optional bytes col_value = 3;
inline bool Field::has_col_value() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Field::set_has_col_value() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Field::clear_has_col_value() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Field::clear_col_value() {
  col_value_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_col_value();
}
inline const ::std::string& Field::col_value() const {
  // @@protoc_insertion_point(field_get:DataMem.Field.col_value)
  return col_value_.GetNoArena();
}
inline void Field::set_col_value(const ::std::string& value) {
  set_has_col_value();
  col_value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:DataMem.Field.col_value)
}
#if LANG_CXX11
inline void Field::set_col_value(::std::string&& value) {
  set_has_col_value();
  col_value_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:DataMem.Field.col_value)
}
#endif
inline void Field::set_col_value(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_col_value();
  col_value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:DataMem.Field.col_value)
}
inline void Field::set_col_value(const void* value, size_t size) {
  set_has_col_value();
  col_value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:DataMem.Field.col_value)
}
inline ::std::string* Field::mutable_col_value() {
  set_has_col_value();
  // @@protoc_insertion_point(field_mutable:DataMem.Field.col_value)
  return col_value_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Field::release_col_value() {
  // @@protoc_insertion_point(field_release:DataMem.Field.col_value)
  if (!has_col_value()) {
    return NULL;
  }
  clear_has_col_value();
  return col_value_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Field::set_allocated_col_value(::std::string* col_value) {
  if (col_value != NULL) {
    set_has_col_value();
  } else {
    clear_has_col_value();
  }
  col_value_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), col_value);
  // @@protoc_insertion_point(field_set_allocated:DataMem.Field.col_value)
}

// optional string col_as = 4;
inline bool Field::has_col_as() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Field::set_has_col_as() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Field::clear_has_col_as() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Field::clear_col_as() {
  col_as_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_col_as();
}
inline const ::std::string& Field::col_as() const {
  // @@protoc_insertion_point(field_get:DataMem.Field.col_as)
  return col_as_.GetNoArena();
}
inline void Field::set_col_as(const ::std::string& value) {
  set_has_col_as();
  col_as_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:DataMem.Field.col_as)
}
#if LANG_CXX11
inline void Field::set_col_as(::std::string&& value) {
  set_has_col_as();
  col_as_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:DataMem.Field.col_as)
}
#endif
inline void Field::set_col_as(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_col_as();
  col_as_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:DataMem.Field.col_as)
}
inline void Field::set_col_as(const char* value, size_t size) {
  set_has_col_as();
  col_as_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:DataMem.Field.col_as)
}
inline ::std::string* Field::mutable_col_as() {
  set_has_col_as();
  // @@protoc_insertion_point(field_mutable:DataMem.Field.col_as)
  return col_as_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Field::release_col_as() {
  // @@protoc_insertion_point(field_release:DataMem.Field.col_as)
  if (!has_col_as()) {
    return NULL;
  }
  clear_has_col_as();
  return col_as_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Field::set_allocated_col_as(::std::string* col_as) {
  if (col_as != NULL) {
    set_has_col_as();
  } else {
    clear_has_col_as();
  }
  col_as_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), col_as);
  // @@protoc_insertion_point(field_set_allocated:DataMem.Field.col_as)
}

// -------------------------------------------------------------------

// MemRsp_DataLocate

// optional uint32 section_from = 1;
inline bool MemRsp_DataLocate::has_section_from() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MemRsp_DataLocate::set_has_section_from() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MemRsp_DataLocate::clear_has_section_from() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MemRsp_DataLocate::clear_section_from() {
  section_from_ = 0u;
  clear_has_section_from();
}
inline ::google::protobuf::uint32 MemRsp_DataLocate::section_from() const {
  // @@protoc_insertion_point(field_get:DataMem.MemRsp.DataLocate.section_from)
  return section_from_;
}
inline void MemRsp_DataLocate::set_section_from(::google::protobuf::uint32 value) {
  set_has_section_from();
  section_from_ = value;
  // @@protoc_insertion_point(field_set:DataMem.MemRsp.DataLocate.section_from)
}

// optional uint32 section_to = 2;
inline bool MemRsp_DataLocate::has_section_to() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MemRsp_DataLocate::set_has_section_to() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MemRsp_DataLocate::clear_has_section_to() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MemRsp_DataLocate::clear_section_to() {
  section_to_ = 0u;
  clear_has_section_to();
}
inline ::google::protobuf::uint32 MemRsp_DataLocate::section_to() const {
  // @@protoc_insertion_point(field_get:DataMem.MemRsp.DataLocate.section_to)
  return section_to_;
}
inline void MemRsp_DataLocate::set_section_to(::google::protobuf::uint32 value) {
  set_has_section_to();
  section_to_ = value;
  // @@protoc_insertion_point(field_set:DataMem.MemRsp.DataLocate.section_to)
}

// optional uint32 hash = 3;
inline bool MemRsp_DataLocate::has_hash() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MemRsp_DataLocate::set_has_hash() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MemRsp_DataLocate::clear_has_hash() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MemRsp_DataLocate::clear_hash() {
  hash_ = 0u;
  clear_has_hash();
}
inline ::google::protobuf::uint32 MemRsp_DataLocate::hash() const {
  // @@protoc_insertion_point(field_get:DataMem.MemRsp.DataLocate.hash)
  return hash_;
}
inline void MemRsp_DataLocate::set_hash(::google::protobuf::uint32 value) {
  set_has_hash();
  hash_ = value;
  // @@protoc_insertion_point(field_set:DataMem.MemRsp.DataLocate.hash)
}

// optional uint32 divisor = 4;
inline bool MemRsp_DataLocate::has_divisor() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void MemRsp_DataLocate::set_has_divisor() {
  _has_bits_[0] |= 0x00000008u;
}
inline void MemRsp_DataLocate::clear_has_divisor() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void MemRsp_DataLocate::clear_divisor() {
  divisor_ = 0u;
  clear_has_divisor();
}
inline ::google::protobuf::uint32 MemRsp_DataLocate::divisor() const {
  // @@protoc_insertion_point(field_get:DataMem.MemRsp.DataLocate.divisor)
  return divisor_;
}
inline void MemRsp_DataLocate::set_divisor(::google::protobuf::uint32 value) {
  set_has_divisor();
  divisor_ = value;
  // @@protoc_insertion_point(field_set:DataMem.MemRsp.DataLocate.divisor)
}

// -------------------------------------------------------------------

// MemRsp

// optional int32 err_no = 1;
inline bool MemRsp::has_err_no() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MemRsp::set_has_err_no() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MemRsp::clear_has_err_no() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MemRsp::clear_err_no() {
  err_no_ = 0;
  clear_has_err_no();
}
inline ::google::protobuf::int32 MemRsp::err_no() const {
  // @@protoc_insertion_point(field_get:DataMem.MemRsp.err_no)
  return err_no_;
}
inline void MemRsp::set_err_no(::google::protobuf::int32 value) {
  set_has_err_no();
  err_no_ = value;
  // @@protoc_insertion_point(field_set:DataMem.MemRsp.err_no)
}

// optional bytes err_msg = 2;
inline bool MemRsp::has_err_msg() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MemRsp::set_has_err_msg() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MemRsp::clear_has_err_msg() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MemRsp::clear_err_msg() {
  err_msg_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_err_msg();
}
inline const ::std::string& MemRsp::err_msg() const {
  // @@protoc_insertion_point(field_get:DataMem.MemRsp.err_msg)
  return err_msg_.GetNoArena();
}
inline void MemRsp::set_err_msg(const ::std::string& value) {
  set_has_err_msg();
  err_msg_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:DataMem.MemRsp.err_msg)
}
#if LANG_CXX11
inline void MemRsp::set_err_msg(::std::string&& value) {
  set_has_err_msg();
  err_msg_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:DataMem.MemRsp.err_msg)
}
#endif
inline void MemRsp::set_err_msg(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_err_msg();
  err_msg_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:DataMem.MemRsp.err_msg)
}
inline void MemRsp::set_err_msg(const void* value, size_t size) {
  set_has_err_msg();
  err_msg_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:DataMem.MemRsp.err_msg)
}
inline ::std::string* MemRsp::mutable_err_msg() {
  set_has_err_msg();
  // @@protoc_insertion_point(field_mutable:DataMem.MemRsp.err_msg)
  return err_msg_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* MemRsp::release_err_msg() {
  // @@protoc_insertion_point(field_release:DataMem.MemRsp.err_msg)
  if (!has_err_msg()) {
    return NULL;
  }
  clear_has_err_msg();
  return err_msg_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void MemRsp::set_allocated_err_msg(::std::string* err_msg) {
  if (err_msg != NULL) {
    set_has_err_msg();
  } else {
    clear_has_err_msg();
  }
  err_msg_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), err_msg);
  // @@protoc_insertion_point(field_set_allocated:DataMem.MemRsp.err_msg)
}

// optional int32 totalcount = 3;
inline bool MemRsp::has_totalcount() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void MemRsp::set_has_totalcount() {
  _has_bits_[0] |= 0x00000008u;
}
inline void MemRsp::clear_has_totalcount() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void MemRsp::clear_totalcount() {
  totalcount_ = 0;
  clear_has_totalcount();
}
inline ::google::protobuf::int32 MemRsp::totalcount() const {
  // @@protoc_insertion_point(field_get:DataMem.MemRsp.totalcount)
  return totalcount_;
}
inline void MemRsp::set_totalcount(::google::protobuf::int32 value) {
  set_has_totalcount();
  totalcount_ = value;
  // @@protoc_insertion_point(field_set:DataMem.MemRsp.totalcount)
}

// optional int32 curcount = 4;
inline bool MemRsp::has_curcount() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void MemRsp::set_has_curcount() {
  _has_bits_[0] |= 0x00000010u;
}
inline void MemRsp::clear_has_curcount() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void MemRsp::clear_curcount() {
  curcount_ = 0;
  clear_has_curcount();
}
inline ::google::protobuf::int32 MemRsp::curcount() const {
  // @@protoc_insertion_point(field_get:DataMem.MemRsp.curcount)
  return curcount_;
}
inline void MemRsp::set_curcount(::google::protobuf::int32 value) {
  set_has_curcount();
  curcount_ = value;
  // @@protoc_insertion_point(field_set:DataMem.MemRsp.curcount)
}

// repeated .DataMem.Record record_data = 5;
inline int MemRsp::record_data_size() const {
  return record_data_.size();
}
inline void MemRsp::clear_record_data() {
  record_data_.Clear();
}
inline ::DataMem::Record* MemRsp::mutable_record_data(int index) {
  // @@protoc_insertion_point(field_mutable:DataMem.MemRsp.record_data)
  return record_data_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::DataMem::Record >*
MemRsp::mutable_record_data() {
  // @@protoc_insertion_point(field_mutable_list:DataMem.MemRsp.record_data)
  return &record_data_;
}
inline const ::DataMem::Record& MemRsp::record_data(int index) const {
  // @@protoc_insertion_point(field_get:DataMem.MemRsp.record_data)
  return record_data_.Get(index);
}
inline ::DataMem::Record* MemRsp::add_record_data() {
  // @@protoc_insertion_point(field_add:DataMem.MemRsp.record_data)
  return record_data_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::DataMem::Record >&
MemRsp::record_data() const {
  // @@protoc_insertion_point(field_list:DataMem.MemRsp.record_data)
  return record_data_;
}

// optional int32 from = 6;
inline bool MemRsp::has_from() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void MemRsp::set_has_from() {
  _has_bits_[0] |= 0x00000020u;
}
inline void MemRsp::clear_has_from() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void MemRsp::clear_from() {
  from_ = 0;
  clear_has_from();
}
inline ::google::protobuf::int32 MemRsp::from() const {
  // @@protoc_insertion_point(field_get:DataMem.MemRsp.from)
  return from_;
}
inline void MemRsp::set_from(::google::protobuf::int32 value) {
  set_has_from();
  from_ = value;
  // @@protoc_insertion_point(field_set:DataMem.MemRsp.from)
}

// optional .DataMem.MemRsp.DataLocate locate = 7;
inline bool MemRsp::has_locate() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MemRsp::set_has_locate() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MemRsp::clear_has_locate() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MemRsp::clear_locate() {
  if (locate_ != NULL) locate_->Clear();
  clear_has_locate();
}
inline const ::DataMem::MemRsp_DataLocate& MemRsp::_internal_locate() const {
  return *locate_;
}
inline const ::DataMem::MemRsp_DataLocate& MemRsp::locate() const {
  const ::DataMem::MemRsp_DataLocate* p = locate_;
  // @@protoc_insertion_point(field_get:DataMem.MemRsp.locate)
  return p != NULL ? *p : *reinterpret_cast<const ::DataMem::MemRsp_DataLocate*>(
      &::DataMem::_MemRsp_DataLocate_default_instance_);
}
inline ::DataMem::MemRsp_DataLocate* MemRsp::release_locate() {
  // @@protoc_insertion_point(field_release:DataMem.MemRsp.locate)
  clear_has_locate();
  ::DataMem::MemRsp_DataLocate* temp = locate_;
  locate_ = NULL;
  return temp;
}
inline ::DataMem::MemRsp_DataLocate* MemRsp::mutable_locate() {
  set_has_locate();
  if (locate_ == NULL) {
    auto* p = CreateMaybeMessage<::DataMem::MemRsp_DataLocate>(GetArenaNoVirtual());
    locate_ = p;
  }
  // @@protoc_insertion_point(field_mutable:DataMem.MemRsp.locate)
  return locate_;
}
inline void MemRsp::set_allocated_locate(::DataMem::MemRsp_DataLocate* locate) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete locate_;
  }
  if (locate) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      locate = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, locate, submessage_arena);
    }
    set_has_locate();
  } else {
    clear_has_locate();
  }
  locate_ = locate;
  // @@protoc_insertion_point(field_set_allocated:DataMem.MemRsp.locate)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace DataMem

namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::DataMem::MemOperate_RedisOperate_OPERATE_TYPE> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::DataMem::MemOperate_RedisOperate_OPERATE_TYPE>() {
  return ::DataMem::MemOperate_RedisOperate_OPERATE_TYPE_descriptor();
}
template <> struct is_proto_enum< ::DataMem::MemOperate_DbOperate_Condition_E_RELATION> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::DataMem::MemOperate_DbOperate_Condition_E_RELATION>() {
  return ::DataMem::MemOperate_DbOperate_Condition_E_RELATION_descriptor();
}
template <> struct is_proto_enum< ::DataMem::MemOperate_DbOperate_ConditionGroup_E_RELATION> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::DataMem::MemOperate_DbOperate_ConditionGroup_E_RELATION>() {
  return ::DataMem::MemOperate_DbOperate_ConditionGroup_E_RELATION_descriptor();
}
template <> struct is_proto_enum< ::DataMem::MemOperate_DbOperate_OrderBy_E_RELATION> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::DataMem::MemOperate_DbOperate_OrderBy_E_RELATION>() {
  return ::DataMem::MemOperate_DbOperate_OrderBy_E_RELATION_descriptor();
}
template <> struct is_proto_enum< ::DataMem::MemOperate_DbOperate_E_QUERY_TYPE> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::DataMem::MemOperate_DbOperate_E_QUERY_TYPE>() {
  return ::DataMem::MemOperate_DbOperate_E_QUERY_TYPE_descriptor();
}
template <> struct is_proto_enum< ::DataMem::MemRsp_E_RESULT_FROM> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::DataMem::MemRsp_E_RESULT_FROM>() {
  return ::DataMem::MemRsp_E_RESULT_FROM_descriptor();
}
template <> struct is_proto_enum< ::DataMem::E_COL_TYPE> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::DataMem::E_COL_TYPE>() {
  return ::DataMem::E_COL_TYPE_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_INCLUDED_dataproxy_2eproto
